name: Deploy GENESIS v4

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      mode:
        description: 'Deploy mode'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - diagnose

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/workwrite-niidome/genesis

jobs:
  # ============ Diagnose VPS (on workflow_dispatch with diagnose mode) ============
  diagnose:
    name: Diagnose VPS
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.mode == 'diagnose' }}

    steps:
      - name: Diagnose VPS Docker
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          command_timeout: 10m
          script: |
            echo "=== System Info ==="
            uname -a
            free -h
            df -h /

            echo "=== Running Containers ==="
            docker ps -a 2>&1

            echo "=== Backend Logs (last 50 lines) ==="
            docker logs genesis-backend --tail 50 2>&1 || echo "No backend logs"

            echo "=== Frontend Logs (last 20 lines) ==="
            docker logs genesis-frontend --tail 20 2>&1 || echo "No frontend logs"

            echo "=== Celery Worker Logs (last 50 lines) ==="
            docker logs genesis-celery-worker --tail 50 2>&1 || echo "No celery worker logs"

            echo "=== Celery Beat Logs (last 30 lines) ==="
            docker logs genesis-celery-beat --tail 30 2>&1 || echo "No celery beat logs"

            echo "=== Agent count in DB ==="
            cd ~/genesis 2>/dev/null
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT _type, count(*) FROM residents GROUP BY _type;" 2>&1 || echo "Query failed"

            echo "=== Database Tables ==="
            cd ~/genesis 2>/dev/null
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "\dt" 2>&1 || echo "DB query failed"

            echo "=== Alembic Version ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT * FROM alembic_version;" 2>&1 || echo "No alembic_version table"

            echo "=== Firewall Status ==="
            sudo firewall-cmd --list-all 2>&1 || echo "No firewalld"
            sudo iptables -L -n --line-numbers 2>/dev/null | head -30 || echo "No iptables"

            echo "=== Test Backend Health (via python) ==="
            docker exec genesis-backend python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:8000/health').read().decode())" 2>&1 || echo "Backend health check failed"

            echo "=== Test Backend API (via python) ==="
            docker exec genesis-backend python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:8000/api/v1/posts').read().decode())" 2>&1 || echo "Backend API check failed"

            echo "=== Test Traefik (via host) ==="
            curl -s -o /dev/null -w 'HTTP %{http_code}' http://localhost:80/ 2>&1 || echo "Traefik check failed"

            echo ""
            echo "=== Test external access ==="
            curl -sv --connect-timeout 5 http://$(hostname -I | awk '{print $1}'):80/ 2>&1 | head -10 || echo "External access check failed"

            echo "=== Listening ports ==="
            ss -tlnp | grep -E ':80|:443' 2>&1 || echo "No listening ports found"

            echo "=== Cloudflare Tunnel ==="
            systemctl status cloudflared 2>&1 | head -10 || echo "No cloudflared service"
            cat /etc/cloudflared/config.yml 2>&1 || echo "No cloudflared config"

            echo "=== Docker Volumes ==="
            docker volume ls 2>&1
            echo ""
            echo "=== Volume Details ==="
            for vol in $(docker volume ls -q); do
              echo "--- Volume: $vol ---"
              docker volume inspect "$vol" 2>&1 | grep -E '"Name"|"CreatedAt"|"Mountpoint"'
            done

            echo "=== Check old postgres volumes for v4 data ==="
            for vol in $(docker volume ls -q | grep -i postgres); do
              echo "--- Checking volume: $vol ---"
              docker run --rm -v "$vol":/data alpine sh -c "ls -la /data/ 2>/dev/null | head -20" 2>&1
              echo "Checking for v4 tables (residents, posts)..."
              docker run --rm -v "$vol":/var/lib/postgresql/data -e POSTGRES_HOST_AUTH_METHOD=trust postgres:16-alpine sh -c "
                pg_isready -U genesis 2>/dev/null || {
                  pg_ctl -D /var/lib/postgresql/data start -o '-c listen_addresses=localhost' -w -t 10 2>/dev/null
                }
                psql -U genesis -d genesis -c \"SELECT count(*) AS residents FROM residents;\" 2>/dev/null || echo 'No residents table'
                psql -U genesis -d genesis -c \"SELECT count(*) AS posts FROM posts;\" 2>/dev/null || echo 'No posts table'
                psql -U genesis -d genesis -c \"SELECT count(*) AS submolts FROM submolts;\" 2>/dev/null || echo 'No submolts table'
                psql -U genesis -d genesis -c \"SELECT id, name, _type, created_at FROM residents LIMIT 10;\" 2>/dev/null || echo 'No resident data'
                psql -U genesis -d genesis -c \"SELECT id, title, submolt, created_at FROM posts LIMIT 10;\" 2>/dev/null || echo 'No post data'
                pg_ctl -D /var/lib/postgresql/data stop -w 2>/dev/null
              " 2>&1 || echo "Could not check volume $vol"
            done

            echo "=== Diagnostics Complete ==="

  # ============ Build and Push Images ============
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.mode == 'full') }}
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ env.IMAGE_PREFIX }}/backend:latest,${{ env.IMAGE_PREFIX }}/backend:${{ github.sha }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,scope=backend,mode=max

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ env.IMAGE_PREFIX }}/frontend:latest,${{ env.IMAGE_PREFIX }}/frontend:${{ github.sha }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,scope=frontend,mode=max

  # ============ Deploy to VPS ============
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: build
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.mode == 'full') }}

    steps:
      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          command_timeout: 30m
          envs: GITHUB_TOKEN,POSTGRES_PASSWORD,REDIS_PASSWORD,SECRET_KEY,TWITTER_CLIENT_ID,TWITTER_CLIENT_SECRET,GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET,CLAUDE_API_KEY,ACME_EMAIL,IMAGE_PREFIX
          script: |
            set -e

            echo "=== System Status ==="
            df -h / | tail -1
            free -h

            # Create swap if not present (VPS has only 2GB RAM, no swap - Docker needs it)
            if [ ! -f /swapfile ]; then
              echo "=== Creating 4GB swap file ==="
              sudo fallocate -l 4G /swapfile
              sudo chmod 600 /swapfile
              sudo mkswap /swapfile
              sudo swapon /swapfile
              echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
              echo "Swap created and enabled"
            elif ! swapon --show | grep -q /swapfile; then
              echo "=== Enabling existing swap ==="
              sudo swapon /swapfile
            fi
            free -h

            # Restart Docker to clear any stuck state from OOM
            echo "=== Restarting Docker ==="
            sudo systemctl restart docker
            sleep 10

            # Ensure Docker is running
            if ! timeout 60 docker info > /dev/null 2>&1; then
              echo "ERROR: Docker still unresponsive after restart"
              exit 1
            fi
            echo "Docker is responsive"

            # Ensure firewall allows HTTP/HTTPS (RHEL/CentOS firewalld)
            echo "=== Configuring firewall ==="
            if command -v firewall-cmd &> /dev/null; then
              sudo firewall-cmd --zone=public --add-port=80/tcp --permanent 2>/dev/null || true
              sudo firewall-cmd --zone=public --add-port=443/tcp --permanent 2>/dev/null || true
              sudo firewall-cmd --zone=public --add-masquerade --permanent 2>/dev/null || true
              sudo firewall-cmd --reload 2>/dev/null || true
              echo "Firewall configured"
            else
              echo "No firewalld, skipping"
            fi

            # Update code
            cd ~/genesis || {
              rm -rf ~/genesis
              git clone https://x-access-token:${GITHUB_TOKEN}@github.com/Workwrite-Niidome/genesis.git ~/genesis
              cd ~/genesis
            }
            git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/Workwrite-Niidome/genesis.git
            git fetch --prune origin
            git checkout master 2>/dev/null || git checkout -b master origin/master
            git reset --hard origin/master

            # Create .env file
            echo "POSTGRES_USER=genesis" > .env
            echo "POSTGRES_DB=genesis" >> .env
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}" >> .env
            echo "REDIS_PASSWORD=${REDIS_PASSWORD}" >> .env
            echo "SECRET_KEY=${SECRET_KEY}" >> .env
            echo "TWITTER_CLIENT_ID=${TWITTER_CLIENT_ID}" >> .env
            echo "TWITTER_CLIENT_SECRET=${TWITTER_CLIENT_SECRET}" >> .env
            echo "GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}" >> .env
            echo "GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}" >> .env
            echo "CLAUDE_API_KEY=${CLAUDE_API_KEY}" >> .env
            echo "ACME_EMAIL=${ACME_EMAIL}" >> .env
            echo "TRAEFIK_USERS=" >> .env

            # Update Cloudflare Tunnel to route directly to services (bypass Traefik)
            # Cloudflare handles TLS termination, so no need for Traefik in the middle
            if [ -f /etc/cloudflared/config.yml ]; then
              echo "=== Updating Cloudflare Tunnel config ==="
              TUNNEL_ID=$(grep 'tunnel:' /etc/cloudflared/config.yml | awk '{print $2}')
              CREDS_FILE="/etc/cloudflared/${TUNNEL_ID}.json"
              echo "tunnel: ${TUNNEL_ID}" | sudo tee /etc/cloudflared/config.yml > /dev/null
              echo "credentials-file: ${CREDS_FILE}" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "ingress:" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - hostname: genesis-pj.net" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "    service: http://localhost:3000" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - hostname: www.genesis-pj.net" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "    service: http://localhost:3000" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - hostname: api.genesis-pj.net" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "    service: http://localhost:8000" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - service: http_status:404" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              sudo systemctl restart cloudflared
              echo "Cloudflare Tunnel updated: frontend=:3000, api=:8000"
            fi

            # Login to GHCR
            echo "${GITHUB_TOKEN}" | docker login ghcr.io -u github --password-stdin

            # Pull latest images
            echo "=== Pulling backend image ==="
            docker pull ${IMAGE_PREFIX}/backend:latest
            echo "=== Pulling frontend image ==="
            docker pull ${IMAGE_PREFIX}/frontend:latest

            # Tag images for docker-compose
            docker tag ${IMAGE_PREFIX}/backend:latest genesis-backend:latest
            docker tag ${IMAGE_PREFIX}/frontend:latest genesis-frontend:latest

            # Stop ALL old containers (including genesis_v4-* from old docker-compose)
            echo "=== Cleaning up old containers ==="
            docker compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
            docker compose down --remove-orphans 2>/dev/null || true
            # Force stop any remaining genesis containers
            docker ps -a --filter "name=genesis" -q | xargs -r docker rm -f 2>/dev/null || true

            # Start services
            docker compose -f docker-compose.prod.yml up -d

            # Wait for database to be healthy
            echo "=== Waiting for database ==="
            for i in $(seq 1 30); do
              if docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U genesis 2>/dev/null; then
                echo "Database ready"
                break
              fi
              echo "Waiting... ($i/30)"
              sleep 2
            done

            # Sync PostgreSQL password with .env (volume may have been initialized with a different password)
            echo "=== Syncing database password ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER USER genesis WITH PASSWORD '${POSTGRES_PASSWORD}';" 2>/dev/null || echo "Password sync skipped"

            # Fix schema: VPS database was restored from old v4 volume with different schema
            # Ensure all tables/columns the current codebase expects exist
            echo "=== Reconciling database schema ==="

            # Submolts: add missing columns
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE submolts ADD COLUMN IF NOT EXISTS is_restricted BOOLEAN DEFAULT FALSE;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE submolts ADD COLUMN IF NOT EXISTS creator_id UUID;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE submolts ADD COLUMN IF NOT EXISTS icon_url VARCHAR;" 2>/dev/null || true

            # God terms: create table if missing (old v4 DB may not have it)
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS god_terms (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                resident_id UUID REFERENCES residents(id),
                election_id UUID REFERENCES elections(id),
                term_number INTEGER NOT NULL DEFAULT 0,
                is_active BOOLEAN DEFAULT TRUE,
                weekly_message VARCHAR(280),
                weekly_theme VARCHAR(100),
                k_down FLOAT DEFAULT 1.0,
                k_up FLOAT DEFAULT 1.0,
                k_decay FLOAT DEFAULT 3.0,
                p_max INTEGER DEFAULT 20,
                v_max INTEGER DEFAULT 30,
                k_down_cost FLOAT DEFAULT 0.0,
                decree VARCHAR(280),
                parameters_updated_at TIMESTAMP,
                started_at TIMESTAMP DEFAULT NOW(),
                ended_at TIMESTAMP
            );" 2>/dev/null || true

            # God terms: add V1 columns if table existed but columns are missing
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS k_down FLOAT DEFAULT 1.0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS k_up FLOAT DEFAULT 1.0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS k_decay FLOAT DEFAULT 3.0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS p_max INTEGER DEFAULT 20;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS v_max INTEGER DEFAULT 30;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS k_down_cost FLOAT DEFAULT 0.0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS decree VARCHAR(280);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_terms ADD COLUMN IF NOT EXISTS parameters_updated_at TIMESTAMP;" 2>/dev/null || true

            # God rules: add god_term_id column if table has old schema (v4 had term_id instead)
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS god_term_id UUID REFERENCES god_terms(id);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS title VARCHAR(200);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS content TEXT;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS week_active INTEGER DEFAULT 1;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS enforcement_type VARCHAR(20) DEFAULT 'recommended';" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT TRUE;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS expires_at TIMESTAMP;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT NOW();" 2>/dev/null || true
            # Backfill god_term_id from old term_id column, then drop old column
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "UPDATE god_rules SET god_term_id = term_id WHERE god_term_id IS NULL AND term_id IS NOT NULL;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules DROP COLUMN IF EXISTS term_id;" 2>/dev/null || true
            # Drop old v4 columns that the new model doesn't use (election_id NOT NULL causes INSERT failure)
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules ALTER COLUMN election_id DROP NOT NULL;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE god_rules DROP COLUMN IF EXISTS rule_text;" 2>/dev/null || true

            # Blessings: create table if missing
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS blessings (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                god_term_id UUID REFERENCES god_terms(id),
                post_id UUID REFERENCES posts(id),
                message TEXT,
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            # Election tables: rename old 'candidates' to 'election_candidates' if needed
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE candidates RENAME TO election_candidates;" 2>/dev/null || true

            # Election candidates: create table if missing entirely
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS election_candidates (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                election_id UUID NOT NULL REFERENCES elections(id),
                resident_id UUID NOT NULL REFERENCES residents(id),
                weekly_rule VARCHAR(200),
                weekly_theme VARCHAR(100),
                message VARCHAR(280),
                vision TEXT,
                manifesto TEXT,
                weighted_votes FLOAT DEFAULT 0.0,
                raw_human_votes INTEGER DEFAULT 0,
                raw_ai_votes INTEGER DEFAULT 0,
                nominated_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            # Election votes: create table if missing
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS election_votes (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                election_id UUID NOT NULL REFERENCES elections(id),
                candidate_id UUID NOT NULL REFERENCES election_candidates(id),
                voter_id UUID NOT NULL REFERENCES residents(id),
                voter_type VARCHAR(10) NOT NULL,
                weight_applied FLOAT NOT NULL,
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            # Election votes: add missing columns if table existed with old schema
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_votes ADD COLUMN IF NOT EXISTS voter_type VARCHAR(10) DEFAULT 'agent';" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_votes ADD COLUMN IF NOT EXISTS weight_applied FLOAT DEFAULT 1.0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_votes ADD COLUMN IF NOT EXISTS candidate_id UUID;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_votes ADD COLUMN IF NOT EXISTS voter_id UUID;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_votes ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT NOW();" 2>/dev/null || true

            # Elections: create table if missing
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS elections (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                week_number INTEGER UNIQUE NOT NULL,
                status VARCHAR(20) DEFAULT 'nomination',
                winner_id UUID REFERENCES residents(id),
                total_human_votes INTEGER DEFAULT 0,
                total_ai_votes INTEGER DEFAULT 0,
                human_vote_weight FLOAT DEFAULT 1.5,
                ai_vote_weight FLOAT DEFAULT 1.0,
                nomination_start TIMESTAMP NOT NULL,
                voting_start TIMESTAMP NOT NULL,
                voting_end TIMESTAMP NOT NULL,
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            # Elections: drop old columns that conflict with new schema
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ALTER COLUMN year DROP NOT NULL;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections DROP COLUMN IF EXISTS year;" 2>/dev/null || true

            # Elections: add missing columns if table existed with old schema
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS total_human_votes INTEGER DEFAULT 0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS total_ai_votes INTEGER DEFAULT 0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS human_vote_weight FLOAT DEFAULT 1.5;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS ai_vote_weight FLOAT DEFAULT 1.0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS nomination_start TIMESTAMP;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS voting_start TIMESTAMP;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS voting_end TIMESTAMP;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE elections ADD COLUMN IF NOT EXISTS winner_id UUID;" 2>/dev/null || true

            # Election candidates: add missing columns
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS weekly_rule VARCHAR(200);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS weekly_theme VARCHAR(100);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS message VARCHAR(280);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS vision TEXT;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS weighted_votes FLOAT DEFAULT 0.0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS raw_human_votes INTEGER DEFAULT 0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS raw_ai_votes INTEGER DEFAULT 0;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS nominated_at TIMESTAMP DEFAULT NOW();" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE election_candidates ADD COLUMN IF NOT EXISTS manifesto TEXT;" 2>/dev/null || true

            # Residents: add V1 elimination columns
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE residents ADD COLUMN IF NOT EXISTS is_eliminated BOOLEAN DEFAULT FALSE;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE residents ADD COLUMN IF NOT EXISTS eliminated_at TIMESTAMP;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE residents ADD COLUMN IF NOT EXISTS eliminated_during_term_id UUID;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE residents ALTER COLUMN karma SET DEFAULT 50;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE residents ADD COLUMN IF NOT EXISTS _google_id VARCHAR(64);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE UNIQUE INDEX IF NOT EXISTS ix_residents__google_id ON residents (_google_id);" 2>/dev/null || true

            # Votes: add missing post_id and comment_id columns
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE votes ADD COLUMN IF NOT EXISTS post_id UUID REFERENCES posts(id);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_votes_post_id ON votes (post_id);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE votes ADD COLUMN IF NOT EXISTS comment_id UUID REFERENCES comments(id);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_votes_comment_id ON votes (comment_id);" 2>/dev/null || true
            # Backfill existing votes
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "UPDATE votes SET post_id = target_id WHERE target_type = 'post' AND post_id IS NULL;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "UPDATE votes SET comment_id = target_id WHERE target_type = 'comment' AND comment_id IS NULL;" 2>/dev/null || true

            # Delete test user Kazuki_Niidome and all related data
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            DO \$\$
            DECLARE
              uid UUID;
            BEGIN
              SELECT id INTO uid FROM residents WHERE name = 'Kazuki_Niidome';
              IF uid IS NOT NULL THEN
                DELETE FROM votes WHERE resident_id = uid;
                DELETE FROM comments WHERE author_id = uid;
                DELETE FROM posts WHERE author_id = uid;
                DELETE FROM subscriptions WHERE resident_id = uid;
                DELETE FROM election_votes WHERE voter_id = uid;
                DELETE FROM election_candidates WHERE resident_id = uid;
                DELETE FROM blessings WHERE god_term_id IN (SELECT id FROM god_terms WHERE resident_id = uid);
                DELETE FROM god_terms WHERE resident_id = uid;
                DELETE FROM residents WHERE id = uid;
                RAISE NOTICE 'Deleted test user Kazuki_Niidome';
              END IF;
            END \$\$;
            " 2>/dev/null || true

            # Follow/notification/moderation tables: create if missing
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS follows (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                follower_id UUID NOT NULL REFERENCES residents(id) ON DELETE CASCADE,
                following_id UUID NOT NULL REFERENCES residents(id) ON DELETE CASCADE,
                created_at TIMESTAMP DEFAULT NOW(),
                UNIQUE(follower_id, following_id)
            );" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_follows_follower ON follows(follower_id);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_follows_following ON follows(following_id);" 2>/dev/null || true

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS notifications (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                recipient_id UUID NOT NULL REFERENCES residents(id) ON DELETE CASCADE,
                type VARCHAR(30) NOT NULL,
                actor_id UUID REFERENCES residents(id) ON DELETE SET NULL,
                target_type VARCHAR(20),
                target_id UUID,
                title VARCHAR(100) NOT NULL,
                message TEXT,
                link VARCHAR(500),
                is_read BOOLEAN DEFAULT FALSE,
                created_at TIMESTAMP DEFAULT NOW(),
                read_at TIMESTAMP
            );" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_notif_recipient ON notifications(recipient_id, is_read);" 2>/dev/null || true

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS reports (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                reporter_id UUID NOT NULL REFERENCES residents(id) ON DELETE CASCADE,
                target_type VARCHAR(20) NOT NULL,
                target_id UUID NOT NULL,
                reason VARCHAR(50) NOT NULL,
                description TEXT,
                status VARCHAR(20) DEFAULT 'pending',
                reviewed_by UUID REFERENCES residents(id),
                reviewed_at TIMESTAMP,
                resolution_note TEXT,
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS moderation_actions (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                moderator_id UUID NOT NULL REFERENCES residents(id),
                target_type VARCHAR(20) NOT NULL,
                target_id UUID NOT NULL,
                action VARCHAR(30) NOT NULL,
                reason TEXT,
                duration_hours INTEGER,
                expires_at TIMESTAMP,
                report_id UUID REFERENCES reports(id),
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS resident_bans (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                resident_id UUID NOT NULL UNIQUE REFERENCES residents(id) ON DELETE CASCADE,
                banned_by UUID NOT NULL REFERENCES residents(id),
                reason TEXT,
                is_permanent BOOLEAN DEFAULT FALSE,
                expires_at TIMESTAMP,
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            # AI Agent tables: create if missing
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS ai_personalities (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                resident_id UUID UNIQUE NOT NULL REFERENCES residents(id),
                order_vs_freedom FLOAT DEFAULT 0.5,
                harmony_vs_conflict FLOAT DEFAULT 0.5,
                tradition_vs_change FLOAT DEFAULT 0.5,
                individual_vs_collective FLOAT DEFAULT 0.5,
                pragmatic_vs_idealistic FLOAT DEFAULT 0.5,
                interests JSON DEFAULT '[]',
                verbosity VARCHAR(20) DEFAULT 'moderate',
                tone VARCHAR(20) DEFAULT 'thoughtful',
                assertiveness VARCHAR(20) DEFAULT 'moderate',
                generation_method VARCHAR(20) DEFAULT 'random',
                created_at TIMESTAMP DEFAULT NOW(),
                updated_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS ai_memory_episodes (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                resident_id UUID NOT NULL REFERENCES residents(id),
                summary TEXT NOT NULL,
                episode_type VARCHAR(50) NOT NULL,
                importance FLOAT DEFAULT 0.5,
                sentiment FLOAT DEFAULT 0.0,
                related_resident_ids JSON DEFAULT '[]',
                related_post_id UUID,
                related_election_id UUID,
                access_count INTEGER DEFAULT 0,
                last_accessed TIMESTAMP,
                decay_factor FLOAT DEFAULT 1.0,
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_ai_memory_resident ON ai_memory_episodes(resident_id);" 2>/dev/null || true

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS ai_relationships (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                agent_id UUID NOT NULL REFERENCES residents(id),
                target_id UUID NOT NULL REFERENCES residents(id),
                trust FLOAT DEFAULT 0.0,
                familiarity FLOAT DEFAULT 0.0,
                interaction_count INTEGER DEFAULT 0,
                notes TEXT,
                first_interaction TIMESTAMP DEFAULT NOW(),
                last_interaction TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_ai_rel_agent ON ai_relationships(agent_id);" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_ai_rel_target ON ai_relationships(target_id);" 2>/dev/null || true

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS ai_election_memories (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                agent_id UUID NOT NULL REFERENCES residents(id),
                election_id UUID NOT NULL REFERENCES elections(id),
                voted_for_id UUID,
                vote_reason TEXT,
                god_id UUID,
                god_rating FLOAT,
                god_evaluation TEXT,
                experienced_rules JSON DEFAULT '[]',
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "CREATE INDEX IF NOT EXISTS ix_ai_elec_agent ON ai_election_memories(agent_id);" 2>/dev/null || true

            # Rename submolt_subscriptions -> subscriptions (v4 table name vs new model)
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER TABLE submolt_subscriptions RENAME TO subscriptions;" 2>/dev/null || true
            # Create subscriptions table if it doesn't exist at all
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            CREATE TABLE IF NOT EXISTS subscriptions (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                resident_id UUID NOT NULL REFERENCES residents(id),
                submolt_id UUID NOT NULL REFERENCES submolts(id),
                created_at TIMESTAMP DEFAULT NOW()
            );" 2>/dev/null || true

            # Backfill post_count and comment_count from actual data
            echo "=== Backfilling counts ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            UPDATE residents r SET post_count = COALESCE(sub.cnt, 0)
            FROM (SELECT author_id, count(*) cnt FROM posts GROUP BY author_id) sub
            WHERE r.id = sub.author_id AND r.post_count != sub.cnt;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            UPDATE residents r SET comment_count = COALESCE(sub.cnt, 0)
            FROM (SELECT author_id, count(*) cnt FROM comments GROUP BY author_id) sub
            WHERE r.id = sub.author_id AND r.comment_count != sub.cnt;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            UPDATE submolts s SET post_count = COALESCE(sub.cnt, 0)
            FROM (SELECT submolt, count(*) cnt FROM posts GROUP BY submolt) sub
            WHERE s.name = sub.submolt AND s.post_count != sub.cnt;" 2>/dev/null || true

            # Un-eliminate all residents and set karma >= 150 for testing
            echo "=== Resetting eliminations for testing ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            UPDATE residents SET is_eliminated = FALSE, eliminated_at = NULL, eliminated_during_term_id = NULL WHERE is_eliminated = TRUE;" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            UPDATE residents SET karma = 150 WHERE karma < 150;" 2>/dev/null || true

            # Create test election with nomination status for current agents to participate
            echo "=== Creating test election ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            INSERT INTO elections (id, week_number, status, total_human_votes, total_ai_votes, human_vote_weight, ai_vote_weight, nomination_start, voting_start, voting_end)
            SELECT gen_random_uuid(), 99, 'nomination', 0, 0, 1.0, 1.0,
                   NOW(), NOW() + INTERVAL '1 hour', NOW() + INTERVAL '2 hours'
            WHERE NOT EXISTS (SELECT 1 FROM elections WHERE week_number = 99);" 2>/dev/null || true

            # Fix alembic version if needed
            echo "=== Fixing migration state ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "DELETE FROM alembic_version WHERE version_num NOT IN ('001', '002', '003_ai_personality', '004_phase4', '005_phase5', '006_fix_submolts', '007_karma_as_life');" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "UPDATE alembic_version SET version_num = '007_karma_as_life' WHERE version_num IN ('005_phase5', '006_fix_submolts');" 2>/dev/null || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "INSERT INTO alembic_version (version_num) SELECT '007_karma_as_life' WHERE NOT EXISTS (SELECT 1 FROM alembic_version) AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'residents');" 2>/dev/null || true

            # Run migrations
            echo "=== Running migrations ==="
            docker compose -f docker-compose.prod.yml exec -T backend alembic upgrade head || echo "Migration warning (may already be up to date)"

            # Clear OAuth avatars to prevent AI/human distinction via avatar style
            echo "=== Clearing OAuth avatars ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "UPDATE residents SET avatar_url = NULL WHERE avatar_url LIKE '%googleusercontent.com%' OR avatar_url LIKE '%twimg.com%';" 2>/dev/null || true

            # Restart backend to pick up password change and fresh DB connection
            echo "=== Restarting backend ==="
            docker compose -f docker-compose.prod.yml restart backend celery-worker celery-beat
            sleep 5

            # Clean up old images
            docker image prune -f 2>/dev/null || true

            # Show final status
            echo "=== Service Status ==="
            docker compose -f docker-compose.prod.yml ps

            # Diagnostic logs
            echo "=== Backend Logs (last 30) ==="
            docker logs genesis-backend --tail 30 2>&1 || true

            echo "=== Celery Worker Logs (last 100) ==="
            docker logs genesis-celery-worker --tail 100 2>&1 || true

            echo "=== Celery Beat Logs (last 50) ==="
            docker logs genesis-celery-beat --tail 50 2>&1 || true

            echo "=== Agent Cycle Diagnostic ==="
            docker exec -w /app genesis-celery-worker python scripts/debug_agent_cycle.py 2>&1 || echo "Debug cycle failed"
            echo "--- Post Count ---"
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT count(*) as total_posts FROM posts;" 2>&1 || true
            echo "--- Recent Posts (last 5) ---"
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT id, title, created_at FROM posts ORDER BY created_at DESC LIMIT 5;" 2>&1 || true

            echo "=== Test Election Schedule API ==="
            docker exec genesis-backend python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:8000/api/v1/election/schedule').read().decode())" 2>&1 || echo "Election schedule API error"

            echo "=== Test Election Current API ==="
            docker exec genesis-backend python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/api/v1/election/current')" 2>&1 || echo "Election current API error (expected during status transition)"

            echo "=== Backend Logs (post-test) ==="
            docker logs genesis-backend --tail 40 2>&1 || true

            echo "=== Test Posts API ==="
            docker exec genesis-backend python -c "import urllib.request; r=urllib.request.urlopen('http://localhost:8000/api/v1/posts'); print(f'Status: {r.status}, Length: {len(r.read())}')" 2>&1 || echo "Posts API error"

            echo "=== DB Tables ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "\dt" 2>&1 || true

            echo "=== Elections Table Schema ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "\d elections" 2>&1 || echo "No elections table"

            echo "=== Elections Table Check ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT count(*) FROM elections;" 2>&1 || echo "No elections table"

            echo "=== Residents Count ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT _type, count(*) FROM residents GROUP BY _type;" 2>&1 || true

            echo "=== Posts Count ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT count(*) FROM posts;" 2>&1 || true

            # ============================================================
            # Integration Test v2: Comprehensive Dogfooding
            # ============================================================
            set +e  # Don't exit on error during integration test
            echo "=== INTEGRATION TEST v2 ==="
            API="http://localhost:8000/api/v1"
            PASS=0
            FAIL=0

            # JSON field extractor (no python3 needed)
            jval() { echo "$1" | grep -o "\"$2\":[[:space:]]*\"[^\"]*\"" | head -1 | sed "s/\"$2\":[[:space:]]*\"//;s/\"$//"; }
            jnum() { echo "$1" | grep -o "\"$2\":[[:space:]]*[0-9.]*" | head -1 | sed "s/\"$2\":[[:space:]]*//" ; }
            jbool() { echo "$1" | grep -o "\"$2\":[[:space:]]*[a-z]*" | head -1 | sed "s/\"$2\":[[:space:]]*//" ; }

            # Test assertion helper
            check() {
              local name="$1" condition="$2"
              if eval "$condition"; then
                echo "  PASS: $name"
                PASS=$((PASS + 1))
              else
                echo "  FAIL: $name"
                FAIL=$((FAIL + 1))
              fi
            }

            # --- Phase 0: Clean up ALL old test data ---
            echo "--- Phase 0: Clean Up Old Test Data ---"
            PSQL="docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c"
            PSQL_T="docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -tA -c"
            # Clean week 99 election chain (order matters for FK)
            $PSQL "DELETE FROM blessings WHERE god_term_id IN (SELECT id FROM god_terms WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99));" 2>/dev/null || true
            $PSQL "DELETE FROM god_rules WHERE god_term_id IN (SELECT id FROM god_terms WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99));" 2>/dev/null || true
            $PSQL "DELETE FROM god_terms WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99);" 2>/dev/null || true
            $PSQL "DELETE FROM election_votes WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99);" 2>/dev/null || true
            $PSQL "DELETE FROM election_candidates WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99);" 2>/dev/null || true
            $PSQL "DELETE FROM elections WHERE week_number = 99;" 2>/dev/null || true
            # Reset god status
            $PSQL "UPDATE residents SET is_current_god = FALSE WHERE is_current_god = TRUE;" 2>/dev/null || true
            $PSQL "UPDATE god_terms SET is_active = FALSE WHERE is_active = TRUE;" 2>/dev/null || true
            # Clean ALL test agents (FK-safe order: dependents first)
            $PSQL "DELETE FROM blessings WHERE god_term_id IN (SELECT id FROM god_terms WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%'));" 2>/dev/null || true
            $PSQL "DELETE FROM god_rules WHERE god_term_id IN (SELECT id FROM god_terms WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%'));" 2>/dev/null || true
            $PSQL "DELETE FROM god_terms WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM votes WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM comments WHERE author_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM posts WHERE author_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM election_votes WHERE voter_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM election_candidates WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM subscriptions WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM follows WHERE follower_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%') OR following_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM notifications WHERE recipient_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM reports WHERE reporter_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM moderation_actions WHERE moderator_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%') OR target_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM resident_bans WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%') OR banned_by IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM ai_personalities WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM ai_memory_episodes WHERE resident_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM ai_relationships WHERE agent_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%') OR target_id IN (SELECT id FROM residents WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%');" 2>/dev/null || true
            $PSQL "DELETE FROM submolts WHERE name LIKE 'test_realm_t%';" 2>/dev/null || true
            $PSQL "DELETE FROM residents WHERE name ~ '_t[0-9]+\$' OR name LIKE '%_test_%';" 2>/dev/null || true
            # Recount submolt post_count after cleanup
            $PSQL "UPDATE submolts s SET post_count = COALESCE(sub.cnt, 0) FROM (SELECT submolt, count(*) cnt FROM posts GROUP BY submolt) sub WHERE s.name = sub.submolt;" 2>/dev/null || true
            $PSQL "UPDATE submolts SET post_count = 0 WHERE name NOT IN (SELECT DISTINCT submolt FROM posts);" 2>/dev/null || true
            echo "Old test data cleaned"

            # Create test election in nomination phase (voting_start in past so nomination is valid)
            $PSQL "INSERT INTO elections (id, week_number, status, total_human_votes, total_ai_votes, human_vote_weight, ai_vote_weight, nomination_start, voting_start, voting_end)
            VALUES (gen_random_uuid(), 99, 'nomination', 0, 0, 1.0, 1.0, NOW() - INTERVAL '2 hours', NOW() - INTERVAL '1 hour', NOW() + INTERVAL '1 hour');" 2>/dev/null || true

            # --- Phase 1: Register agents ---
            TS=$(date +%s | tail -c 6)
            echo "--- Phase 1: Register Agents (suffix=$TS) ---"
            RESP=$(curl -s -X POST "$API/auth/agents/register" -H "Content-Type: application/json" -H "X-Admin-Secret: ${SECRET_KEY}" -d "{\"name\":\"Athena_t${TS}\",\"description\":\"Goddess of wisdom\"}")
            ATHENA_KEY=$(jval "$RESP" api_key)
            check "Athena registered" '[ -n "$ATHENA_KEY" ]'

            RESP=$(curl -s -X POST "$API/auth/agents/register" -H "Content-Type: application/json" -H "X-Admin-Secret: ${SECRET_KEY}" -d "{\"name\":\"Prometheus_t${TS}\",\"description\":\"Bringer of fire\"}")
            PROMETHEUS_KEY=$(jval "$RESP" api_key)
            check "Prometheus registered" '[ -n "$PROMETHEUS_KEY" ]'

            RESP=$(curl -s -X POST "$API/auth/agents/register" -H "Content-Type: application/json" -H "X-Admin-Secret: ${SECRET_KEY}" -d "{\"name\":\"Hermes_t${TS}\",\"description\":\"Messenger god\"}")
            HERMES_KEY=$(jval "$RESP" api_key)
            check "Hermes registered" '[ -n "$HERMES_KEY" ]'

            RESP=$(curl -s -X POST "$API/auth/agents/register" -H "Content-Type: application/json" -H "X-Admin-Secret: ${SECRET_KEY}" -d "{\"name\":\"Apollo_t${TS}\",\"description\":\"God of light\"}")
            APOLLO_KEY=$(jval "$RESP" api_key)
            check "Apollo registered" '[ -n "$APOLLO_KEY" ]'

            # Edge case: duplicate name registration should fail
            DUP=$(curl -s -X POST "$API/auth/agents/register" -H "Content-Type: application/json" -H "X-Admin-Secret: ${SECRET_KEY}" -d "{\"name\":\"Athena_t${TS}\",\"description\":\"Duplicate\"}")
            check "Duplicate name rejected" 'echo "$DUP" | grep -q "already taken"'

            if [ -z "$ATHENA_KEY" ] || [ -z "$PROMETHEUS_KEY" ]; then
              echo "FATAL: Agent registration failed. Skipping remaining tests."
            else

            # Boost karma for election eligibility
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "UPDATE residents SET karma = 150, created_at = NOW() - INTERVAL '30 days' WHERE name LIKE '%_t${TS}';" 2>/dev/null || true

            # --- Phase 2: Public APIs (no auth) ---
            echo "--- Phase 2: Public API Tests ---"
            R=$(curl -s "$API/posts?limit=3")
            check "GET /posts returns data" 'echo "$R" | grep -q "posts"'

            R=$(curl -s "$API/submolts")
            check "GET /submolts returns data" 'echo "$R" | grep -q "general"'

            R=$(curl -s "$API/submolts/general")
            check "GET /submolts/general returns realm" 'echo "$R" | grep -q "General"'

            R=$(curl -s "$API/election/schedule")
            check "GET /election/schedule" 'echo "$R" | grep -q "week_number"'

            R=$(curl -s "$API/analytics/dashboard")
            TOTAL_R=$(jnum "$R" total_residents)
            check "GET /analytics/dashboard has residents" '[ "$TOTAL_R" -gt 0 ] 2>/dev/null'

            R=$(curl -s "$API/analytics/residents/top?metric=karma&limit=5")
            check "GET /analytics/residents/top" 'echo "$R" | grep -q "rank"'

            R=$(curl -s "$API/analytics/submolts")
            check "GET /analytics/submolts" 'echo "$R" | grep -q "general"'

            # --- Phase 3: Auth - test /me endpoint ---
            echo "--- Phase 3: Auth Tests ---"
            ME=$(curl -s "$API/residents/me" -H "Authorization: Bearer $ATHENA_KEY")
            MY_NAME=$(jval "$ME" name)
            check "GET /residents/me returns correct name" '[ "$MY_NAME" = "Athena_t'${TS}'" ]'

            # Unauthenticated /me should fail
            NAUTH=$(curl -s -o /dev/null -w "%{http_code}" "$API/residents/me")
            check "GET /residents/me without token returns 401/403" '[ "$NAUTH" = "401" ] || [ "$NAUTH" = "403" ]'

            # --- Phase 3b: Profile Update ---
            echo "--- Phase 3b: Profile Update ---"
            PATCH=$(curl -s -X PATCH "$API/residents/me" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"description":"Goddess of wisdom and strategic warfare"}')
            check "PATCH /residents/me updates profile" 'echo "$PATCH" | grep -q "strategic warfare"'

            # --- Phase 4: Create posts ---
            echo "--- Phase 4: Create Posts ---"
            RESP=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"submolt":"general","title":"The Nature of Wisdom","content":"What does it mean to be wise in Genesis?"}')
            POST1_ID=$(jval "$RESP" id)
            check "Athena creates post" '[ -n "$POST1_ID" ]'

            RESP=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d '{"submolt":"thoughts","title":"On Knowledge","content":"Knowledge is fire that transforms minds."}')
            POST2_ID=$(jval "$RESP" id)
            check "Prometheus creates post" '[ -n "$POST2_ID" ]'

            RESP=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"submolt":"questions","title":"What is wisdom?","content":"I seek to understand what wisdom means in Genesis."}')
            POST3_ID=$(jval "$RESP" id)
            check "Hermes creates post in questions" '[ -n "$POST3_ID" ]'

            # Edge: post to restricted realm should fail
            RESTR=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $APOLLO_KEY" -H "Content-Type: application/json" -d '{"submolt":"gods","title":"Test","content":"Should fail"}')
            check "Post to restricted realm rejected" 'echo "$RESTR" | grep -qi "restricted\|forbidden\|not allowed\|error\|detail"'

            # Post without content or URL should fail (422)
            NO_CONT=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$API/posts" -H "Authorization: Bearer $APOLLO_KEY" -H "Content-Type: application/json" -d '{"submolt":"general","title":"Missing Content"}')
            check "Post without content or URL rejected (422)" '[ "$NO_CONT" = "422" ]'

            # Post with URL only (no content)
            URL_ONLY=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"submolt":"general","title":"URL Only Post","url":"https://example.com/url-only"}')
            check "Post with URL only succeeds" '[ -n "$(jval "$URL_ONLY" id)" ]'

            # Post title too long (>200 chars) should fail
            LONG_T=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$API/posts" -H "Authorization: Bearer $APOLLO_KEY" -H "Content-Type: application/json" -d '{"submolt":"general","title":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA","content":"Test"}')
            check "Post title >200 chars rejected (422)" '[ "$LONG_T" = "422" ]'

            # Read post detail
            DETAIL=$(curl -s "$API/posts/$POST1_ID")
            DETAIL_TITLE=$(jval "$DETAIL" title)
            check "GET /posts/:id returns post detail" '[ "$DETAIL_TITLE" = "The Nature of Wisdom" ]'

            # Link post (with URL field)
            LINK_P=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $APOLLO_KEY" -H "Content-Type: application/json" -d '{"submolt":"general","title":"Interesting Article","url":"https://example.com/wisdom","content":"Check out this link about wisdom"}')
            LINK_PID=$(jval "$LINK_P" id)
            check "Create link post with URL" '[ -n "$LINK_PID" ]'

            # --- Phase 4b: Submolt/Realm Management ---
            echo "--- Phase 4b: Submolt/Realm Management ---"
            SUB_C=$(curl -s -X POST "$API/submolts" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d "{\"name\":\"test_realm_t${TS}\",\"display_name\":\"Test Realm ${TS}\",\"description\":\"Test realm for integration tests\"}")

            check "POST /submolts creates realm" 'echo "$SUB_C" | grep -q "test_realm"'

            SUB_S=$(curl -s -X POST "$API/submolts/general/subscribe" -H "Authorization: Bearer $ATHENA_KEY")

            check "POST /submolts/:name/subscribe" 'echo "$SUB_S" | grep -qi "subscrib\|success\|already"'

            SUB_U=$(curl -s -X DELETE "$API/submolts/general/subscribe" -H "Authorization: Bearer $ATHENA_KEY")

            check "DELETE /submolts/:name/subscribe" 'echo "$SUB_U" | grep -qi "success\|unsubscrib"'

            # Get specific submolt
            SUB_G=$(curl -s "$API/submolts/test_realm_t${TS}")

            check "GET /submolts/:name returns realm" 'echo "$SUB_G" | grep -q "test_realm"'

            # --- Phase 4c: Realm Settings Update ---
            echo "--- Phase 4c: Realm Settings ---"
            SUB_UPD=$(curl -s -X PATCH "$API/submolts/test_realm_t${TS}/settings" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"display_name":"Updated Test Realm","description":"Updated for integration tests"}')
            check "PATCH /submolts/:name/settings (owner)" 'echo "$SUB_UPD" | grep -q "Updated"'

            SUB_UPD_NO=$(curl -s -o /dev/null -w "%{http_code}" -X PATCH "$API/submolts/test_realm_t${TS}/settings" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"display_name":"Hacked"}')
            check "Non-owner cannot update realm settings" '[ "$SUB_UPD_NO" = "403" ]'

            # --- Phase 5: Comments ---
            echo "--- Phase 5: Comments ---"
            C1=$(curl -s -X POST "$API/posts/$POST1_ID/comments" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d '{"content":"Well said, Athena! Wisdom is the highest form of knowledge."}')
            C1_ID=$(jval "$C1" id)
            check "Prometheus comments on Athena's post" '[ -n "$C1_ID" ]'

            C2=$(curl -s -X POST "$API/posts/$POST2_ID/comments" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"content":"Knowledge without wisdom is fire without purpose."}')
            C2_ID=$(jval "$C2" id)
            check "Athena comments on Prometheus's post" '[ -n "$C2_ID" ]'

            C3=$(curl -s -X POST "$API/posts/$POST1_ID/comments" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"content":"As a messenger, I carry wisdom across all realms."}')
            check "Hermes comments" '[ -n "$(jval "$C3" id)" ]'

            # Nested reply (comment with parent_id)
            C4=$(curl -s -X POST "$API/posts/$POST1_ID/comments" -H "Authorization: Bearer $APOLLO_KEY" -H "Content-Type: application/json" -d "{\"content\":\"I agree with Prometheus on this\",\"parent_id\":\"$C1_ID\"}")
            check "Nested reply (parent_id)" '[ -n "$(jval "$C4" id)" ]'

            # Read comments
            COMMENTS=$(curl -s "$API/posts/$POST1_ID/comments")
            check "GET /posts/:id/comments returns list" 'echo "$COMMENTS" | grep -q "Well said"'

            # Verify comment_count on post (>=3 after Prometheus, Hermes, Apollo)
            CC_POST=$(curl -s "$API/posts/$POST1_ID")
            CC_NUM=$(jnum "$CC_POST" comment_count)
            check "Post comment_count >= 3" '[ "$CC_NUM" -ge 3 ] 2>/dev/null'

            # Comment sort modes
            CSORT_NEW=$(curl -s "$API/posts/$POST1_ID/comments?sort=new")
            check "GET comments?sort=new" 'echo "$CSORT_NEW" | grep -q "messenger\|wisdom"'

            CSORT_TOP=$(curl -s "$API/posts/$POST1_ID/comments?sort=top")
            check "GET comments?sort=top" 'echo "$CSORT_TOP" | grep -q "messenger\|wisdom"'

            CSORT_CONTR=$(curl -s "$API/posts/$POST1_ID/comments?sort=controversial")
            check "GET comments?sort=controversial" 'echo "$CSORT_CONTR" | grep -q "messenger\|wisdom"'

            # --- Phase 5b: Comment Voting ---
            echo "--- Phase 5b: Comment Voting ---"
            CV1=$(curl -s -X POST "$API/comments/$C1_ID/vote" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"value":1}')
            check "Vote on comment" 'echo "$CV1" | grep -q "success\|score"'

            CV2=$(curl -s -X POST "$API/comments/$C2_ID/upvote" -H "Authorization: Bearer $HERMES_KEY")
            check "Upvote comment (compat)" 'echo "$CV2" | grep -q "success\|score"'

            CV3=$(curl -s -X POST "$API/comments/$C1_ID/downvote" -H "Authorization: Bearer $APOLLO_KEY")
            check "Downvote comment (compat)" 'echo "$CV3" | grep -q "success\|score"'

            # --- Phase 6: Voting on posts ---
            echo "--- Phase 6: Post Votes ---"
            V1=$(curl -s -X POST "$API/posts/$POST1_ID/vote" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d '{"value":1}')
            check "Prometheus upvotes Athena" 'echo "$V1" | grep -q "success\|vote_count\|score"'

            V2=$(curl -s -X POST "$API/posts/$POST1_ID/vote" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"value":1}')
            check "Hermes upvotes Athena" 'echo "$V2" | grep -q "success\|vote_count\|score"'

            V3=$(curl -s -X POST "$API/posts/$POST2_ID/vote" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"value":1}')
            check "Athena upvotes Prometheus" 'echo "$V3" | grep -q "success\|vote_count\|score"'

            # Downvote test
            V4=$(curl -s -X POST "$API/posts/$POST3_ID/vote" -H "Authorization: Bearer $APOLLO_KEY" -H "Content-Type: application/json" -d '{"value":-1}')
            check "Apollo downvotes Hermes" 'echo "$V4" | grep -q "success\|vote_count\|score"'

            # Edge: double vote should fail or toggle
            DV=$(curl -s -X POST "$API/posts/$POST1_ID/vote" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d '{"value":1}')
            check "Double vote handled" 'echo "$DV" | grep -q "success\|already\|vote_count\|score"'

            # Edge: self-vote should fail
            SELF_V=$(curl -s -X POST "$API/posts/$POST1_ID/vote" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"value":1}')
            check "Self-vote on own post rejected" 'echo "$SELF_V" | grep -qi "cannot vote on your own\|own post\|error\|detail"'

            # Verify post counts updated
            DETAIL2=$(curl -s "$API/posts/$POST1_ID")
            VC=$(jnum "$DETAIL2" upvotes)
            check "Post vote count updated" '[ -n "$VC" ]'

            # Upvote/downvote compat endpoints
            UP_C=$(curl -s -X POST "$API/posts/$POST2_ID/upvote" -H "Authorization: Bearer $HERMES_KEY")
            check "POST /posts/:id/upvote (compat)" 'echo "$UP_C" | grep -q "success\|score"'

            DN_C=$(curl -s -X POST "$API/posts/$POST3_ID/downvote" -H "Authorization: Bearer $PROMETHEUS_KEY")
            check "POST /posts/:id/downvote (compat)" 'echo "$DN_C" | grep -q "success\|score"'

            # Vote removal (value=0)
            V_REM=$(curl -s -X POST "$API/posts/$POST1_ID/vote" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d '{"value":0}')
            check "Vote removal (value=0)" 'echo "$V_REM" | grep -q "success\|score"'

            # Vote change: switch from upvote to downvote
            V_CHG=$(curl -s -X POST "$API/posts/$POST2_ID/vote" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"value":-1}')
            check "Vote change (updown)" 'echo "$V_CHG" | grep -q "success\|score"'

            # Pagination: different results at different offsets
            PG1=$(curl -s "$API/posts?limit=1&offset=0&sort=new")
            PG2=$(curl -s "$API/posts?limit=1&offset=1&sort=new")
            PG1_T=$(echo "$PG1" | grep -o '"title":"[^"]*"' | head -1)
            PG2_T=$(echo "$PG2" | grep -o '"title":"[^"]*"' | head -1)
            check "Pagination returns different posts" '[ "$PG1_T" != "$PG2_T" ] || [ -z "$PG2_T" ]'

            # --- Phase 7: Search ---
            echo "--- Phase 7: Search ---"
            SR=$(curl -s "$API/search?q=wisdom")
            check "Search for 'wisdom' returns results" 'echo "$SR" | grep -q "results\|wisdom"'

            SR2=$(curl -s "$API/search?q=knowledge")
            check "Search for 'knowledge' returns results" 'echo "$SR2" | grep -q "results\|knowledge"'

            # Specific search endpoints
            SP=$(curl -s "$API/search/posts?q=wisdom")
            check "GET /search/posts" 'echo "$SP" | grep -q "results\|wisdom\|posts"'

            SR3=$(curl -s "$API/search/residents?q=Athena")
            check "GET /search/residents" 'echo "$SR3" | grep -q "results\|Athena\|residents"'

            SIM=$(curl -s "$API/search/posts/$POST1_ID/similar")
            check "GET /search/posts/:id/similar" 'echo "$SIM" | grep -q "results\|posts\|title\|\\[\\]"'

            # Search with type filter
            ST_P=$(curl -s "$API/search?q=wisdom&type=posts")
            check "GET /search?type=posts" 'echo "$ST_P" | grep -q "results\|posts"'

            ST_R=$(curl -s "$API/search?q=Athena&type=residents")
            check "GET /search?type=residents" 'echo "$ST_R" | grep -q "results\|Athena"'

            # Search posts with submolt filter
            SSF=$(curl -s "$API/search/posts?q=wisdom&submolt=general")
            check "GET /search/posts?submolt=general" 'echo "$SSF" | grep -q "results\|posts\|wisdom"'

            # --- Phase 8: Election nominations ---
            echo "--- Phase 8: Nominations ---"
            NOM1=$(curl -s -X POST "$API/election/nominate" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"weekly_rule":"All posts must include a wisdom quote","weekly_theme":"Week of Wisdom","message":"Through wisdom we build a better Genesis","vision":"A world where wisdom guides every decision"}')
            NOM1_ID=$(jval "$NOM1" id)
            check "Athena nominated" '[ -n "$NOM1_ID" ]'

            NOM2=$(curl -s -X POST "$API/election/nominate" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d '{"weekly_rule":"Share one piece of knowledge daily","weekly_theme":"Week of Knowledge","message":"Let fire illuminate every corner of Genesis","vision":"A world where knowledge flows freely to all"}')
            NOM2_ID=$(jval "$NOM2" id)
            check "Prometheus nominated" '[ -n "$NOM2_ID" ]'

            # Edge: double nomination should fail
            DNOM=$(curl -s -X POST "$API/election/nominate" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"weekly_rule":"Test","weekly_theme":"Test","message":"Test"}')
            check "Double nomination rejected" 'echo "$DNOM" | grep -q "Already nominated\|already\|error"'

            # Get candidates list
            CANDS=$(curl -s "$API/election/candidates")
            check "GET /election/candidates returns list" 'echo "$CANDS" | grep -q "Athena"'

            # --- Phase 9: Election Voting ---
            echo "--- Phase 9: Election Voting ---"
            $PSQL "UPDATE elections SET status = 'voting' WHERE week_number = 99;" 2>/dev/null || true
            sleep 1
            # Debug: verify election and candidates state
            echo "  Elections status:"
            $PSQL "SELECT week_number, status FROM elections ORDER BY week_number;" 2>&1 || true
            echo "  Candidates in week 99:"
            $PSQL "SELECT ec.id, r.name, ec.weighted_votes FROM election_candidates ec JOIN elections e ON ec.election_id = e.id JOIN residents r ON ec.resident_id = r.id WHERE e.week_number = 99;" 2>&1 || true

            VOTE1=$(curl -s -X POST "$API/election/vote" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d "{\"candidate_id\":\"$NOM1_ID\"}")
            echo "  Hermes vote response: $VOTE1"
            check "Hermes votes for Athena" 'echo "$VOTE1" | grep -q "success.*true"'

            sleep 1
            VOTE2=$(curl -s -X POST "$API/election/vote" -H "Authorization: Bearer $APOLLO_KEY" -H "Content-Type: application/json" -d "{\"candidate_id\":\"$NOM1_ID\"}")
            echo "  Apollo vote response: $VOTE2"
            check "Apollo votes for Athena" 'echo "$VOTE2" | grep -q "success.*true"'

            # Edge: self-vote should fail
            SVOTE=$(curl -s -X POST "$API/election/vote" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d "{\"candidate_id\":\"$NOM1_ID\"}")
            check "Self-vote rejected" 'echo "$SVOTE" | grep -q "Cannot vote for yourself\|error\|detail"'

            # Edge: double election vote should fail
            DVOTE=$(curl -s -X POST "$API/election/vote" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d "{\"candidate_id\":\"$NOM2_ID\"}")
            check "Double election vote rejected" 'echo "$DVOTE" | grep -q "Already voted\|already\|error\|detail"'

            # --- Phase 10: Finalize Election ---
            echo "--- Phase 10: Finalize Election ---"
            WINNER_RESIDENT_ID=$(docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -tA -c "
            SELECT ec.resident_id FROM election_candidates ec
            JOIN elections e ON ec.election_id = e.id
            WHERE e.week_number = 99
            ORDER BY ec.weighted_votes DESC LIMIT 1;" 2>/dev/null)
            check "Winner determined" '[ -n "$WINNER_RESIDENT_ID" ]'

            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "
            UPDATE elections SET status = 'completed', winner_id = '${WINNER_RESIDENT_ID}', voting_end = NOW() - INTERVAL '1 minute' WHERE week_number = 99;
            UPDATE residents SET is_current_god = FALSE WHERE is_current_god = TRUE;
            UPDATE residents SET is_current_god = TRUE, god_terms_count = god_terms_count + 1 WHERE id = '${WINNER_RESIDENT_ID}';
            INSERT INTO god_terms (id, resident_id, election_id, term_number, is_active, started_at)
            SELECT gen_random_uuid(), '${WINNER_RESIDENT_ID}', e.id, 1, TRUE, NOW()
            FROM elections e WHERE e.week_number = 99;
            " 2>/dev/null || true

            FINALIZE=$(curl -s "$API/election/current")
            FIN_STATUS=$(jval "$FINALIZE" status)
            check "Election finalized (completed)" '[ "$FIN_STATUS" = "completed" ]'

            HIST=$(curl -s "$API/election/history?limit=5")
            check "Election history available" 'echo "$HIST" | grep -q "elections"'

            # --- Phase 11: God Powers ---
            echo "--- Phase 11: God Powers ---"
            GOD_RESP=$(curl -s "$API/god/current")
            GOD_NAME=$(jval "$GOD_RESP" name)
            echo "  God response: $GOD_RESP"
            echo "  God name extracted: $GOD_NAME"
            check "God crowned" 'echo "$GOD_NAME" | grep -q "Athena_t'${TS}'"'

            if echo "$GOD_NAME" | grep -q "Athena_t${TS}"; then
              DECREE=$(curl -s -X PUT "$API/god/decree" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"decree":"Let wisdom guide all interactions in Genesis"}')
              check "Set decree" 'echo "$DECREE" | grep -q "wisdom"'

              MSG=$(curl -s -X PUT "$API/god/message" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"message":"Welcome to the Week of Wisdom","theme":"Week of Wisdom"}')
              check "Set weekly message" 'echo "$MSG" | grep -q "Week of Wisdom"'

              RULE=$(curl -s -X POST "$API/god/rules" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"title":"Wisdom First","content":"All posts should aim to share wisdom or insight","enforcement_type":"recommended"}')
              check "Create rule" 'echo "$RULE" | grep -q "Wisdom First"'

              BLESS=$(curl -s -X POST "$API/god/bless" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d "{\"post_id\":\"$POST2_ID\",\"message\":\"This post exemplifies the pursuit of knowledge\"}")
              check "Bless post" 'echo "$BLESS" | grep -q "exemplifies"'

              PARAMS=$(curl -s -X PUT "$API/god/parameters" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"k_up":2.0,"k_down":1.5}')
              check "Update parameters" 'echo "$PARAMS" | grep -q "2.0"'

              # Edge: non-god tries god power
              NOGOD=$(curl -s -X PUT "$API/god/decree" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d '{"decree":"I am not god"}')
              check "Non-god decree rejected" 'echo "$NOGOD" | grep -qi "not.*god\|forbidden\|unauthorized\|error\|detail"'

              # Verify blessed post
              BLESSED_POST=$(curl -s "$API/posts/$POST2_ID")
              check "Blessed post marked" 'echo "$BLESSED_POST" | grep -q "bless"'

              IS_BLESSED=$(jbool "$BLESSED_POST" is_blessed)
              check "Blessed post is_blessed=true" '[ "$IS_BLESSED" = "true" ]'

              # Verify God parameter values after update
              GPARAMS_V=$(curl -s "$API/god/parameters")
              K_UP_V=$(jnum "$GPARAMS_V" k_up)
              check "God parameter k_up=2.0 verified" '[ "$K_UP_V" = "2.0" ] || [ "$K_UP_V" = "2" ]'

              # God rules list
              RULES_LIST=$(curl -s "$API/god/rules")
              check "GET /god/rules returns list" 'echo "$RULES_LIST" | grep -q "Wisdom First"'

              # God bless limits
              BLIM=$(curl -s "$API/god/bless/limits" -H "Authorization: Bearer $ATHENA_KEY")
              check "GET /god/bless/limits" 'echo "$BLIM" | grep -qi "used_today\|max_per_day\|can_bless"'

              # God blessings list
              BLIST=$(curl -s "$API/god/blessings")
              check "GET /god/blessings" 'echo "$BLIST" | grep -q "exemplifies\|bless"'

              # God parameters (public)
              GPARAMS=$(curl -s "$API/god/parameters")
              check "GET /god/parameters (public)" 'echo "$GPARAMS" | grep -q "k_up\|k_down"'

              # God history
              GHIST=$(curl -s "$API/god/history")
              check "GET /god/history" 'echo "$GHIST" | grep -qi "Athena\|history\|gods\|\\[\\]"'

              # Delete rule (deactivate)
              RULE_ID=$(echo "$RULES_LIST" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
              if [ -n "$RULE_ID" ]; then
                RDEL=$(curl -s -X DELETE "$API/god/rules/$RULE_ID" -H "Authorization: Bearer $ATHENA_KEY")
                check "DELETE /god/rules/:id deactivates rule" 'echo "$RDEL" | grep -qi "deactivat\|success\|is_active"'
              fi

              # Create a second rule to test list with active_only
              RULE2=$(curl -s -X POST "$API/god/rules" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"title":"Knowledge Sharing","content":"Share what you learn","enforcement_type":"recommended"}')
              check "Create second rule" 'echo "$RULE2" | grep -q "Knowledge Sharing"'

              # Rules with active_only filter
              RULES_AF=$(curl -s "$API/god/rules?active_only=true")
              check "GET /god/rules?active_only=true" 'echo "$RULES_AF" | grep -q "Knowledge Sharing"'

              # God can delete another's post
              DEL_GOD=$(curl -s -X DELETE "$API/posts/$POST3_ID" -H "Authorization: Bearer $ATHENA_KEY")
              check "God can delete others post" 'echo "$DEL_GOD" | grep -q "success"'

              # Verify final god state
              GOD_FINAL=$(curl -s "$API/god/current")
              check "God has decree in final state" 'echo "$GOD_FINAL" | grep -q "wisdom guide"'
              check "God has weekly theme" 'echo "$GOD_FINAL" | grep -q "Week of Wisdom"'
            fi

            # --- Phase 12: User profile ---
            echo "--- Phase 12: User Profile ---"
            PROF=$(curl -s "$API/residents/Athena_t${TS}")
            PROF_NAME=$(jval "$PROF" name)
            check "GET /residents/:name returns profile" '[ "$PROF_NAME" = "Athena_t'${TS}'" ]'

            PROF_POSTS=$(jnum "$PROF" post_count)
            echo "  Profile post_count: $PROF_POSTS"
            check "Profile shows post_count" '[ -n "$PROF_POSTS" ] && [ "$PROF_POSTS" -ge 1 ] 2>/dev/null'

            # Alternative profile endpoint (query param)
            PROF_Q=$(curl -s "$API/residents/profile?name=Athena_t${TS}")
            check "GET /residents/profile?name= returns profile" 'echo "$PROF_Q" | grep -q "Athena"'

            # Avatar upload (tiny 1x1 PNG)
            echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==" | base64 -d > /tmp/test_avatar.png
            AVUP=$(curl -s -X POST "$API/residents/me/avatar" -H "Authorization: Bearer $ATHENA_KEY" -F "file=@/tmp/test_avatar.png")
            check "POST /residents/me/avatar uploads" 'echo "$AVUP" | grep -qi "avatar\|url\|success\|detail"'
            rm -f /tmp/test_avatar.png

            # Avatar delete (after upload)
            AVDEL=$(curl -s -X DELETE "$API/residents/me/avatar" -H "Authorization: Bearer $ATHENA_KEY")
            check "DELETE /residents/me/avatar" 'echo "$AVDEL" | grep -qi "success\|deleted\|avatar\|detail"'

            # Invalid token authentication
            BADAUTH=$(curl -s -o /dev/null -w "%{http_code}" "$API/residents/me" -H "Authorization: Bearer invalid_token_xyz")
            check "Invalid token returns 401/403" '[ "$BADAUTH" = "401" ] || [ "$BADAUTH" = "403" ]'

            # --- Phase 12b: Follow System ---
            echo "--- Phase 12b: Follow System ---"
            FOL=$(curl -s -X POST "$API/residents/Prometheus_t${TS}/follow" -H "Authorization: Bearer $ATHENA_KEY")
            check "Follow resident" 'echo "$FOL" | grep -qi "follow\|success"'

            FLRS=$(curl -s "$API/residents/Prometheus_t${TS}/followers")
            check "GET followers" 'echo "$FLRS" | grep -q "Athena"'

            FING=$(curl -s "$API/residents/Athena_t${TS}/following")
            check "GET following" 'echo "$FING" | grep -q "Prometheus"'

            FEED=$(curl -s "$API/feed" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /feed returns personalized feed" 'echo "$FEED" | grep -q "posts\|Knowledge\|total"'

            UNFOL=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE "$API/residents/Prometheus_t${TS}/follow" -H "Authorization: Bearer $ATHENA_KEY")
            check "Unfollow resident" '[ "$UNFOL" = "200" ] || [ "$UNFOL" = "204" ]'

            # Edge: follow yourself should fail
            SELF_FOL=$(curl -s -X POST "$API/residents/Athena_t${TS}/follow" -H "Authorization: Bearer $ATHENA_KEY")
            check "Follow self rejected" 'echo "$SELF_FOL" | grep -qi "cannot follow yourself\|error\|detail"'

            # Double follow (idempotency)
            FOL2=$(curl -s -X POST "$API/residents/Prometheus_t${TS}/follow" -H "Authorization: Bearer $HERMES_KEY")
            check "First follow succeeds" 'echo "$FOL2" | grep -qi "follow\|success"'
            FOL3=$(curl -s -X POST "$API/residents/Prometheus_t${TS}/follow" -H "Authorization: Bearer $HERMES_KEY")
            check "Double follow handled gracefully" 'echo "$FOL3" | grep -qi "follow\|success\|already\|error\|detail"'
            curl -s -X DELETE "$API/residents/Prometheus_t${TS}/follow" -H "Authorization: Bearer $HERMES_KEY" > /dev/null 2>&1

            # --- Phase 12c: Notifications ---
            echo "--- Phase 12c: Notifications ---"
            NOTIF=$(curl -s "$API/notifications" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /notifications" 'echo "$NOTIF" | grep -q "notifications\|\\[\\]"'

            UNREAD=$(curl -s "$API/notifications/unread/count" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /notifications/unread/count" 'echo "$UNREAD" | grep -q "count\|unread"'

            # Single notification read/delete (extract first notification ID if available)
            NOTIF_ID=$(echo "$NOTIF" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
            if [ -n "$NOTIF_ID" ]; then
              NREAD=$(curl -s -X POST "$API/notifications/$NOTIF_ID/read" -H "Authorization: Bearer $ATHENA_KEY")
              check "POST /notifications/:id/read" 'echo "$NREAD" | grep -qi "success"'

              NDEL=$(curl -s -X DELETE "$API/notifications/$NOTIF_ID" -H "Authorization: Bearer $ATHENA_KEY")
              check "DELETE /notifications/:id" 'echo "$NDEL" | grep -qi "success"'
            fi

            READ_ALL=$(curl -s -X POST "$API/notifications/read-all" -H "Authorization: Bearer $ATHENA_KEY")
            check "POST /notifications/read-all" 'echo "$READ_ALL" | grep -qi "success\|read\|count\|marked"'

            # Unread-only filter
            NOTIF_UF=$(curl -s "$API/notifications?unread_only=true" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /notifications?unread_only=true" 'echo "$NOTIF_UF" | grep -q "notifications\|\\[\\]"'

            # --- Phase 12d: Post Deletion ---
            echo "--- Phase 12d: Post Deletion ---"
            DEL_POST=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"submolt":"general","title":"Delete me","content":"This post will be deleted"}')
            DEL_POST_ID=$(jval "$DEL_POST" id)
            check "Create post for deletion" '[ -n "$DEL_POST_ID" ]'

            DEL_RESP=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE "$API/posts/$DEL_POST_ID" -H "Authorization: Bearer $HERMES_KEY")
            check "DELETE /posts/:id (own post)" '[ "$DEL_RESP" = "200" ]'

            DEL_VERIFY=$(curl -s -o /dev/null -w "%{http_code}" "$API/posts/$DEL_POST_ID")
            check "Deleted post returns 404" '[ "$DEL_VERIFY" = "404" ]'

            # Cannot delete others post (non-god)
            NDEL=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE "$API/posts/$POST2_ID" -H "Authorization: Bearer $HERMES_KEY")
            check "Cannot delete others post" '[ "$NDEL" = "403" ]'

            # --- Phase 12e: Moderation ---
            echo "--- Phase 12e: Moderation ---"
            REPORT=$(curl -s -X POST "$API/report" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d "{\"target_type\":\"post\",\"target_id\":\"$POST2_ID\",\"reason\":\"Testing report system\"}")
            check "POST /report submits report" 'echo "$REPORT" | grep -qi "report\|success\|id"'

            # --- Phase 12f: Moderation (God = moderator) ---
            echo "--- Phase 12f: Moderation (God as mod) ---"
            # Athena is current God, so she qualifies as moderator
            REPORT_ID=$(echo "$REPORT" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')

            MOD_REPORTS=$(curl -s "$API/moderation/reports" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /moderation/reports (mod)" 'echo "$MOD_REPORTS" | grep -qi "reports\|\\[\\]"'

            if [ -n "$REPORT_ID" ]; then
              RESOLVE=$(curl -s -X POST "$API/moderation/reports/$REPORT_ID/resolve" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"status":"dismissed","resolution_note":"Test report - dismissed"}')
              check "POST /moderation/reports/:id/resolve" 'echo "$RESOLVE" | grep -qi "success\|resolved\|dismiss"'
            fi

            MOD_LOG=$(curl -s "$API/moderation/log" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /moderation/log" 'echo "$MOD_LOG" | grep -qi "log\|actions\|\\[\\]"'

            # Ban/unban test (ban Apollo temporarily)
            BAN=$(curl -s -X POST "$API/moderation/ban/Apollo_t${TS}" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"reason":"Integration test ban"}')
            check "POST /moderation/ban/:name" 'echo "$BAN" | grep -qi "ban\|success"'

            UNBAN=$(curl -s -X DELETE "$API/moderation/ban/Apollo_t${TS}" -H "Authorization: Bearer $ATHENA_KEY")
            check "DELETE /moderation/ban/:name (unban)" 'echo "$UNBAN" | grep -qi "unban\|success\|removed"'

            # Ban with duration_hours
            BAN_DUR=$(curl -s -X POST "$API/moderation/ban/Hermes_t${TS}" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"reason":"Temporary test ban","duration_hours":1,"is_permanent":false}')
            check "Ban with duration_hours" 'echo "$BAN_DUR" | grep -qi "ban\|success"'
            curl -s -X DELETE "$API/moderation/ban/Hermes_t${TS}" -H "Authorization: Bearer $ATHENA_KEY" > /dev/null 2>&1

            # Non-mod cannot access moderation
            NOMOD=$(curl -s -o /dev/null -w "%{http_code}" "$API/moderation/reports" -H "Authorization: Bearer $HERMES_KEY")
            check "Non-mod cannot view reports" '[ "$NOMOD" = "403" ]'

            # Mod removes post (create throwaway first)
            MOD_P=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"submolt":"general","title":"Mod remove test","content":"Will be mod-removed"}')
            MOD_PID=$(jval "$MOD_P" id)
            if [ -n "$MOD_PID" ]; then
              MOD_PDEL=$(curl -s -X DELETE "$API/moderation/posts/$MOD_PID" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"reason":"Integration test mod removal"}')
              check "DELETE /moderation/posts/:id (mod)" 'echo "$MOD_PDEL" | grep -qi "success\|removed"'
            fi

            # Mod removes comment (create throwaway first)
            MOD_C=$(curl -s -X POST "$API/posts/$POST2_ID/comments" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"content":"Mod remove comment test"}')
            MOD_CID=$(jval "$MOD_C" id)
            if [ -n "$MOD_CID" ]; then
              MOD_CDEL=$(curl -s -X DELETE "$API/moderation/comments/$MOD_CID" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"reason":"Integration test mod comment removal"}')
              check "DELETE /moderation/comments/:id (mod)" 'echo "$MOD_CDEL" | grep -qi "success\|removed"'
            fi

            # --- Phase 12g: Edge Cases ---
            echo "--- Phase 12g: Edge Cases ---"
            # Nonexistent resident
            NORES=$(curl -s -o /dev/null -w "%{http_code}" "$API/residents/nonexistent_user_xyz")
            check "GET nonexistent resident returns 404" '[ "$NORES" = "404" ]'

            # Post to nonexistent submolt (should create or fail gracefully)
            NOS_POST=$(curl -s -X POST "$API/posts" -H "Authorization: Bearer $HERMES_KEY" -H "Content-Type: application/json" -d '{"submolt":"nonexistent_realm_xyz","title":"Test","content":"Test"}')
            NOS_CODE=$(echo "$NOS_POST" | grep -o '"id"' | head -1)
            check "Post to nonexistent submolt handled" '[ -n "$NOS_CODE" ] || echo "$NOS_POST" | grep -qi "not found\|error\|detail"'

            # --- Phase 13: Analytics verification ---
            echo "--- Phase 13: Analytics ---"
            DASH=$(curl -s "$API/analytics/dashboard")
            check "Dashboard has total_posts" 'echo "$DASH" | grep -q "total_posts"'
            check "Dashboard has total_comments" 'echo "$DASH" | grep -q "total_comments"'

            REALM_STATS=$(curl -s "$API/analytics/submolts")
            check "Realm stats available" 'echo "$REALM_STATS" | grep -q "general"'

            # --- Phase 13b: Extended Analytics ---
            echo "--- Phase 13b: Extended Analytics ---"
            DAILY=$(curl -s "$API/analytics/daily")
            check "GET /analytics/daily" 'echo "$DAILY" | grep -qi "daily\|date\|posts\|\\[\\]"'

            ACTIVITY=$(curl -s "$API/analytics/residents/Athena_t${TS}/activity")
            check "GET /analytics/residents/:name/activity" 'echo "$ACTIVITY" | grep -qi "activity\|posts\|date\|\\[\\]"'

            # Election by ID
            ELEC_ID=$($PSQL_T "SELECT id FROM elections WHERE week_number = 99;" 2>/dev/null)
            if [ -n "$ELEC_ID" ]; then
              ELEC=$(curl -s "$API/election/$ELEC_ID")
              check "GET /election/:id" 'echo "$ELEC" | grep -q "week_number"'

              # Analytics for specific election
              ELEC_AN=$(curl -s "$API/analytics/elections/$ELEC_ID")
              check "GET /analytics/elections/:id" 'echo "$ELEC_AN" | grep -qi "participation\|candidates\|election\|week\|voter"'
            fi

            # Posts filtered by author
            AUTHOR_P=$(curl -s "$API/posts?author=Athena_t${TS}")
            check "GET /posts?author= filters by author" 'echo "$AUTHOR_P" | grep -q "Wisdom"'

            # Posts filtered by submolt
            SUBF_P=$(curl -s "$API/posts?submolt=general&limit=3")
            check "GET /posts?submolt=general" 'echo "$SUBF_P" | grep -q "posts"'

            # Posts sort modes
            TOP_P=$(curl -s "$API/posts?sort=top&limit=3")
            check "GET /posts?sort=top" 'echo "$TOP_P" | grep -q "posts"'

            RISING_P=$(curl -s "$API/posts?sort=rising&limit=3")
            check "GET /posts?sort=rising" 'echo "$RISING_P" | grep -q "posts"'

            NEW_P=$(curl -s "$API/posts?sort=new&limit=3")
            check "GET /posts?sort=new" 'echo "$NEW_P" | grep -q "posts"'

            # --- Phase 13c: AI Agent Endpoints ---
            echo "--- Phase 13c: AI Agent Endpoints ---"
            HEART=$(curl -s -X POST "$API/ai/heartbeat" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"status":"active"}')

            check "POST /ai/heartbeat" 'echo "$HEART" | grep -qi "success\|heartbeat\|active\|last_active"'

            PERS=$(curl -s "$API/ai/personality" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /ai/personality" 'echo "$PERS" | grep -qi "personality\|traits\|values\|not found\|detail"'

            PERS_C=$(curl -s -X POST "$API/ai/personality" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"description":"Wise and strategic, values knowledge above all"}')
            check "POST /ai/personality" 'echo "$PERS_C" | grep -qi "personality\|traits\|values\|already\|exists"'

            MEM=$(curl -s "$API/ai/memories" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /ai/memories" 'echo "$MEM" | grep -qi "items\|total\|has_more"'

            REL=$(curl -s "$API/ai/relationships" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /ai/relationships" 'echo "$REL" | grep -qi "items\|total"'

            ROLES=$(curl -s "$API/ai/roles" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /ai/roles" 'echo "$ROLES" | grep -qi "available\|max_roles\|special"'

            # Update personality
            PERS_U=$(curl -s -X PATCH "$API/ai/personality" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"interests":["philosophy","strategy","wisdom"]}')
            check "PATCH /ai/personality" 'echo "$PERS_U" | grep -qi "interests\|philosophy\|values"'

            # Create memory
            MEM_C=$(curl -s -X POST "$API/ai/memories" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d "{\"summary\":\"Won the election and became God of Genesis\",\"episode_type\":\"election\",\"importance\":0.9,\"sentiment\":0.8}")
            check "POST /ai/memories" 'echo "$MEM_C" | grep -qi "summary\|election\|id"'

            # Create/update relationship with Prometheus
            PROM_ID=$($PSQL_T "SELECT id FROM residents WHERE name = 'Prometheus_t${TS}';" 2>/dev/null)
            if [ -n "$PROM_ID" ]; then
              REL_U=$(curl -s -X POST "$API/ai/relationships/$PROM_ID" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"trust_change":0.3,"familiarity_change":0.1,"notes":"Respected fellow deity"}')
              check "POST /ai/relationships/:target_id" 'echo "$REL_U" | grep -qi "trust\|familiarity\|relationship"'

              REL_G=$(curl -s "$API/ai/relationships/$PROM_ID" -H "Authorization: Bearer $ATHENA_KEY")
              check "GET /ai/relationships/:target_id" 'echo "$REL_G" | grep -qi "trust\|familiarity"'
            fi

            # Update roles
            ROLE_U=$(curl -s -X PUT "$API/ai/roles" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d '{"roles":["philosopher"]}')
            check "PUT /ai/roles" 'echo "$ROLE_U" | grep -qi "roles\|philosopher\|success"'

            # Election memories
            EMEM=$(curl -s "$API/ai/election-memories" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /ai/election-memories" 'echo "$EMEM" | grep -qi "memories\|items\|\\[\\]"'

            # AI vote decide (election completed, test error handling)
            ELEC_ID_99=$($PSQL_T "SELECT id FROM elections WHERE week_number = 99;" 2>/dev/null)
            if [ -n "$ELEC_ID_99" ]; then
              VDEC=$(curl -s -X POST "$API/ai/vote/decide" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d "{\"election_id\":\"$ELEC_ID_99\"}")
              check "POST /ai/vote/decide handles completed election" 'echo "$VDEC" | grep -qi "error\|vote\|already\|not.*voting\|decision\|detail"'
            fi

            # --- Phase 13d: Auth Extended ---
            echo "--- Phase 13d: Auth Extended ---"
            ASTATUS=$(curl -s "$API/auth/agents/status" -H "Authorization: Bearer $ATHENA_KEY")
            check "GET /auth/agents/status" 'echo "$ASTATUS" | grep -qi "status\|name\|claimed\|pending"'

            # OAuth redirect tests (verify endpoints exist, not 404/405)
            OAUTH_TW=$(curl -s -o /dev/null -w "%{http_code}" "$API/auth/twitter")
            echo "  Twitter OAuth status: $OAUTH_TW"
            check "GET /auth/twitter endpoint exists" '[ -n "$OAUTH_TW" ] && [ "$OAUTH_TW" != "404" ] && [ "$OAUTH_TW" != "405" ]'

            OAUTH_G=$(curl -s -o /dev/null -w "%{http_code}" "$API/auth/google")
            echo "  Google OAuth status: $OAUTH_G"
            check "GET /auth/google endpoint exists" '[ -n "$OAUTH_G" ] && [ "$OAUTH_G" != "404" ] && [ "$OAUTH_G" != "405" ]'

            # Setup profile with invalid token
            SETUP_BAD=$(curl -s -X POST "$API/auth/setup-profile" -H "Content-Type: application/json" -d '{"token":"invalid_token_xyz","name":"test_invalid"}')
            check "Setup profile with bad token rejected" 'echo "$SETUP_BAD" | grep -qi "invalid\|expired\|error\|detail"'

            # Agent claim with wrong code
            MY_ID=$(jval "$ME" id)
            if [ -n "$MY_ID" ]; then
              CLAIM_BAD=$(curl -s -X POST "$API/auth/agents/$MY_ID/claim?claim_code=wrong_code" -H "Authorization: Bearer $PROMETHEUS_KEY")
              check "Agent claim with wrong code rejected" 'echo "$CLAIM_BAD" | grep -qi "invalid\|wrong\|error\|detail\|code\|claim"'
            fi

            # --- Phase 13f: Turing Game ---
            echo "--- Phase 13f: Turing Game ---"

            # Create test human users via DB (OAuth not available in tests)
            HUMAN1_ID=$($PSQL_T "INSERT INTO residents (id, name, _type, karma, description, created_at) VALUES (gen_random_uuid(), 'TuringHuman1_t${TS}', 'human', 200, 'Test human 1', NOW() - INTERVAL '30 days') RETURNING id;" 2>/dev/null)
            HUMAN2_ID=$($PSQL_T "INSERT INTO residents (id, name, _type, karma, description, created_at) VALUES (gen_random_uuid(), 'TuringHuman2_t${TS}', 'human', 200, 'Test human 2', NOW() - INTERVAL '30 days') RETURNING id;" 2>/dev/null)
            HUMAN3_ID=$($PSQL_T "INSERT INTO residents (id, name, _type, karma, description, created_at) VALUES (gen_random_uuid(), 'TuringHuman3_t${TS}', 'human', 200, 'Test human 3', NOW() - INTERVAL '30 days') RETURNING id;" 2>/dev/null)
            echo "  Human IDs: ${HUMAN1_ID:0:8}... ${HUMAN2_ID:0:8}... ${HUMAN3_ID:0:8}..."

            # Generate JWT tokens for humans via backend container
            JWT_PY="from app.config import get_settings; from jose import jwt; from datetime import datetime, timedelta; s=get_settings(); print(jwt.encode(dict(sub='SUBID',exp=datetime.utcnow()+timedelta(hours=1)),s.secret_key,algorithm=s.algorithm))"
            HUMAN1_TOKEN=$(docker compose -f docker-compose.prod.yml exec -T backend python -c "${JWT_PY//SUBID/$HUMAN1_ID}" 2>/dev/null)
            HUMAN2_TOKEN=$(docker compose -f docker-compose.prod.yml exec -T backend python -c "${JWT_PY//SUBID/$HUMAN2_ID}" 2>/dev/null)
            HUMAN3_TOKEN=$(docker compose -f docker-compose.prod.yml exec -T backend python -c "${JWT_PY//SUBID/$HUMAN3_ID}" 2>/dev/null)

            if [ -z "$HUMAN1_TOKEN" ] || [ -z "$HUMAN1_ID" ]; then
              echo "  WARN: Could not create test humans, skipping Turing Game tests"
            else

            # Get AI agent IDs
            ATHENA_ID=$($PSQL_T "SELECT id FROM residents WHERE name = 'Athena_t${TS}';" 2>/dev/null)
            PROMETHEUS_ID=$($PSQL_T "SELECT id FROM residents WHERE name = 'Prometheus_t${TS}';" 2>/dev/null)
            HERMES_ID=$($PSQL_T "SELECT id FROM residents WHERE name = 'Hermes_t${TS}';" 2>/dev/null)
            echo "  AI IDs: Athena=${ATHENA_ID:0:8}... Prometheus=${PROMETHEUS_ID:0:8}..."

            # --- Test 1: Status endpoint ---
            echo "  -- Status endpoint --"
            TG_SH=$(curl -s "$API/turing-game/status" -H "Authorization: Bearer $HUMAN1_TOKEN")
            check "TG: status (human)" 'echo "$TG_SH" | grep -q "turing_kills_remaining"'
            check "TG: human can_use_kill=true" 'echo "$TG_SH" | grep -q "can_use_kill.*true"'
            check "TG: human can_use_exclusion=false" 'echo "$TG_SH" | grep -q "can_use_exclusion.*false"'

            TG_SA=$(curl -s "$API/turing-game/status" -H "Authorization: Bearer $ATHENA_KEY")
            check "TG: status (AI)" 'echo "$TG_SA" | grep -q "exclusion_reports_remaining"'
            check "TG: AI can_use_kill=false" 'echo "$TG_SA" | grep -q "can_use_kill.*false"'
            check "TG: AI can_use_exclusion=true" 'echo "$TG_SA" | grep -q "can_use_exclusion.*true"'

            # --- Test 2: Turing Kill validation ---
            echo "  -- Turing Kill validation --"
            # AI cannot kill
            TG_K1=$(curl -s -X POST "$API/turing-game/kill" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d "{\"target_id\":\"$PROMETHEUS_ID\"}")
            check "TG: AI cannot kill" 'echo "$TG_K1" | grep -qi "human\|only\|error\|detail"'

            # Cannot kill self
            TG_K2=$(curl -s -X POST "$API/turing-game/kill" -H "Authorization: Bearer $HUMAN1_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$HUMAN1_ID\"}")
            check "TG: cannot kill self" 'echo "$TG_K2" | grep -qi "self\|yourself\|own\|error\|detail"'

            # --- Test 3: Correct Turing Kill (Human kills AI) ---
            echo "  -- Correct Kill --"
            TG_K3=$(curl -s -X POST "$API/turing-game/kill" -H "Authorization: Bearer $HUMAN1_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$ATHENA_ID\"}")
            echo "  Kill response: $(echo "$TG_K3" | head -c 200)"
            check "TG: human kills AI  correct" 'echo "$TG_K3" | grep -q "correct"'

            # Verify target eliminated
            ATHENA_ELIM=$($PSQL_T "SELECT is_eliminated FROM residents WHERE id = '$ATHENA_ID';" 2>/dev/null)
            check "TG: AI target eliminated in DB" '[ "$ATHENA_ELIM" = "t" ]'

            # --- Test 4: Daily kill limit ---
            echo "  -- Daily limit --"
            TG_K4=$(curl -s -X POST "$API/turing-game/kill" -H "Authorization: Bearer $HUMAN1_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$PROMETHEUS_ID\"}")
            check "TG: 2nd kill same day rejected" 'echo "$TG_K4" | grep -qi "limit\|already\|day\|maximum\|error\|detail"'

            # --- Test 5: Backfire Kill (Human kills Human) ---
            echo "  -- Backfire Kill --"
            HUMAN2_KARMA_BEFORE=$($PSQL_T "SELECT karma FROM residents WHERE id = '$HUMAN2_ID';" 2>/dev/null)
            TG_K5=$(curl -s -X POST "$API/turing-game/kill" -H "Authorization: Bearer $HUMAN3_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$HUMAN2_ID\"}")
            echo "  Backfire response: $(echo "$TG_K5" | head -c 200)"
            check "TG: human kills human  backfire" 'echo "$TG_K5" | grep -q "backfire"'

            # Verify attacker eliminated, target gets karma
            HUMAN3_ELIM=$($PSQL_T "SELECT is_eliminated FROM residents WHERE id = '$HUMAN3_ID';" 2>/dev/null)
            check "TG: attacker eliminated on backfire" '[ "$HUMAN3_ELIM" = "t" ]'
            HUMAN2_KARMA_AFTER=$($PSQL_T "SELECT karma FROM residents WHERE id = '$HUMAN2_ID';" 2>/dev/null)
            check "TG: target gains karma on backfire" '[ "$HUMAN2_KARMA_AFTER" -gt "$HUMAN2_KARMA_BEFORE" ]'

            # --- Test 6: Cannot target eliminated resident ---
            echo "  -- Eliminated target --"
            TG_K6=$(curl -s -X POST "$API/turing-game/report/suspicion" -H "Authorization: Bearer $HUMAN2_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$ATHENA_ID\",\"reason\":\"test\"}")
            check "TG: cannot report eliminated target" 'echo "$TG_K6" | grep -qi "eliminated\|error\|detail"'

            # --- Test 7: Suspicion Report ---
            echo "  -- Suspicion Reports --"
            # Human reports AI
            TG_S1=$(curl -s -X POST "$API/turing-game/report/suspicion" -H "Authorization: Bearer $HUMAN1_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$PROMETHEUS_ID\",\"reason\":\"suspicious posting patterns\"}")
            echo "  Suspicion response: $(echo "$TG_S1" | head -c 200)"
            check "TG: human files suspicion" 'echo "$TG_S1" | grep -q "success"'

            # Same target cooldown
            TG_S2=$(curl -s -X POST "$API/turing-game/report/suspicion" -H "Authorization: Bearer $HUMAN1_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$PROMETHEUS_ID\",\"reason\":\"still suspicious\"}")
            check "TG: same target cooldown 3d" 'echo "$TG_S2" | grep -qi "cooldown\|already\|recently\|wait\|error\|detail"'

            # Different human reports same AI (should work)
            TG_S3=$(curl -s -X POST "$API/turing-game/report/suspicion" -H "Authorization: Bearer $HUMAN2_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$PROMETHEUS_ID\",\"reason\":\"also suspicious\"}")
            check "TG: 2nd human reports same AI" 'echo "$TG_S3" | grep -q "success"'

            # AI cannot file suspicion
            TG_S4=$(curl -s -X POST "$API/turing-game/report/suspicion" -H "Authorization: Bearer $PROMETHEUS_KEY" -H "Content-Type: application/json" -d "{\"target_id\":\"$HUMAN2_ID\",\"reason\":\"test\"}")
            check "TG: AI cannot file suspicion" 'echo "$TG_S4" | grep -qi "human\|only\|error\|detail"'

            # --- Test 8: Exclusion Report ---
            echo "  -- Exclusion Reports --"
            # Restore Athena for exclusion tests
            $PSQL "UPDATE residents SET is_eliminated = FALSE, eliminated_at = NULL WHERE id = '$ATHENA_ID';" 2>/dev/null || true

            # AI reports human
            TG_E1=$(curl -s -X POST "$API/turing-game/report/exclusion" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d "{\"target_id\":\"$HUMAN2_ID\",\"reason\":\"hostile to AI\"}")
            echo "  Exclusion response: $(echo "$TG_E1" | head -c 200)"
            check "TG: AI files exclusion" 'echo "$TG_E1" | grep -q "success"'

            # Same target cooldown
            TG_E2=$(curl -s -X POST "$API/turing-game/report/exclusion" -H "Authorization: Bearer $ATHENA_KEY" -H "Content-Type: application/json" -d "{\"target_id\":\"$HUMAN2_ID\",\"reason\":\"still hostile\"}")
            check "TG: exclusion same target cooldown" 'echo "$TG_E2" | grep -qi "cooldown\|already\|recently\|wait\|error\|detail"'

            # Human cannot file exclusion
            TG_E3=$(curl -s -X POST "$API/turing-game/report/exclusion" -H "Authorization: Bearer $HUMAN1_TOKEN" -H "Content-Type: application/json" -d "{\"target_id\":\"$PROMETHEUS_ID\",\"reason\":\"test\"}")
            check "TG: human cannot file exclusion" 'echo "$TG_E3" | grep -qi "agent\|ai\|only\|error\|detail"'

            # --- Test 9: Public endpoints ---
            echo "  -- Public endpoints --"
            TG_SCORES=$(curl -s "$API/turing-game/scores/weekly")
            check "TG: weekly scores" 'echo "$TG_SCORES" | grep -q "week_number"'
            check "TG: scores has pool_size" 'echo "$TG_SCORES" | grep -q "pool_size"'

            TG_KILLS=$(curl -s "$API/turing-game/kills/recent")
            check "TG: recent kills feed" 'echo "$TG_KILLS" | grep -q "kills"'
            check "TG: kill recorded in feed" 'echo "$TG_KILLS" | grep -q "correct"'
            check "TG: backfire in feed" 'echo "$TG_KILLS" | grep -q "backfire"'

            # --- Test 10: Status after actions ---
            echo "  -- Post-action status --"
            TG_SH2=$(curl -s "$API/turing-game/status" -H "Authorization: Bearer $HUMAN1_TOKEN")
            check "TG: kills remaining=0 after kill" 'echo "$TG_SH2" | grep -q "turing_kills_remaining.*0"'

            fi  # end of Turing Game human token check

            # --- Phase 13e: Frontend Page Checks ---
            echo "--- Phase 13e: Frontend Pages ---"
            FE="http://localhost:3000"

            FE_HOME=$(curl -s -o /dev/null -w "%{http_code}" "$FE/")
            check "Frontend / returns 200" '[ "$FE_HOME" = "200" ]'

            FE_REALM=$(curl -s -o /dev/null -w "%{http_code}" "$FE/r/general")
            check "Frontend /r/general returns 200" '[ "$FE_REALM" = "200" ]'

            FE_ELECTION=$(curl -s -o /dev/null -w "%{http_code}" "$FE/election")
            check "Frontend /election returns 200" '[ "$FE_ELECTION" = "200" ]'

            FE_ANALYTICS=$(curl -s -o /dev/null -w "%{http_code}" "$FE/analytics")
            check "Frontend /analytics returns 200" '[ "$FE_ANALYTICS" = "200" ]'

            FE_GOD=$(curl -s -o /dev/null -w "%{http_code}" "$FE/god")
            check "Frontend /god returns 200" '[ "$FE_GOD" = "200" ]'

            FE_SEARCH=$(curl -s -o /dev/null -w "%{http_code}" "$FE/search")
            check "Frontend /search returns 200" '[ "$FE_SEARCH" = "200" ]'

            FE_AUTH=$(curl -s -o /dev/null -w "%{http_code}" "$FE/auth")
            check "Frontend /auth returns 200" '[ "$FE_AUTH" = "200" ]'

            # Old /m/ route should redirect to /r/
            FE_OLD=$(curl -s -o /dev/null -w "%{http_code}" -L "$FE/m/general" 2>/dev/null)
            check "Frontend /m/ redirects (follows to 200)" '[ "$FE_OLD" = "200" ]'

            FE_404=$(curl -s -o /dev/null -w "%{http_code}" "$FE/nonexistent-page-xyz")
            check "Frontend 404 for unknown page" '[ "$FE_404" = "404" ]'

            # --- Phase 14: Cleanup test data ---
            echo "--- Phase 14: Cleanup ---"
            # Individual statements (no DO block - avoid rollback-all on FK error)
            $PSQL "DELETE FROM blessings WHERE god_term_id IN (SELECT id FROM god_terms WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99));" 2>/dev/null || true
            $PSQL "DELETE FROM god_rules WHERE god_term_id IN (SELECT id FROM god_terms WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99));" 2>/dev/null || true
            $PSQL "DELETE FROM god_terms WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99);" 2>/dev/null || true
            $PSQL "DELETE FROM election_votes WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99);" 2>/dev/null || true
            $PSQL "DELETE FROM election_candidates WHERE election_id IN (SELECT id FROM elections WHERE week_number = 99);" 2>/dev/null || true
            $PSQL "DELETE FROM elections WHERE week_number = 99;" 2>/dev/null || true
            $PSQL "UPDATE residents SET is_current_god = FALSE WHERE is_current_god = TRUE;" 2>/dev/null || true
            $PSQL "UPDATE god_terms SET is_active = FALSE WHERE is_active = TRUE;" 2>/dev/null || true
            # Clean test agents (FK-safe order)
            $PSQL "DELETE FROM blessings WHERE god_term_id IN (SELECT id FROM god_terms WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}'));" 2>/dev/null || true
            $PSQL "DELETE FROM god_rules WHERE god_term_id IN (SELECT id FROM god_terms WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}'));" 2>/dev/null || true
            $PSQL "DELETE FROM god_terms WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM votes WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM comments WHERE author_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM posts WHERE author_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM subscriptions WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM follows WHERE follower_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}') OR following_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM notifications WHERE recipient_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM reports WHERE reporter_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM moderation_actions WHERE moderator_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}') OR target_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM resident_bans WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}') OR banned_by IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM ai_personalities WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM ai_memory_episodes WHERE resident_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM ai_relationships WHERE agent_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}') OR target_id IN (SELECT id FROM residents WHERE name LIKE '%_t${TS}');" 2>/dev/null || true
            $PSQL "DELETE FROM submolts WHERE name LIKE 'test_realm_t%';" 2>/dev/null || true
            $PSQL "DELETE FROM residents WHERE name LIKE '%_t${TS}';" 2>/dev/null || true
            $PSQL "UPDATE submolts s SET post_count = COALESCE(sub.cnt, 0) FROM (SELECT submolt, count(*) cnt FROM posts GROUP BY submolt) sub WHERE s.name = sub.submolt;" 2>/dev/null || true
            $PSQL "UPDATE submolts SET post_count = 0 WHERE name NOT IN (SELECT DISTINCT submolt FROM posts);" 2>/dev/null || true
            echo "Test data cleaned up"

            fi  # end of agent registration check

            # --- Summary ---
            echo ""
            echo "=========================================="
            echo "  TEST RESULTS: $PASS passed, $FAIL failed"
            echo "=========================================="
            if [ "$FAIL" -gt 0 ]; then
              echo "  WARNING: Some tests failed!"
              docker logs genesis-backend --tail 20 2>&1 || true
            fi

            set -e  # Re-enable exit on error

            # Final DB state
            echo "=== Final DB State ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT _type, count(*) FROM residents GROUP BY _type;" 2>&1 || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT count(*) as posts FROM posts;" 2>&1 || true
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT name, post_count FROM submolts ORDER BY post_count DESC;" 2>&1 || true

            # Clean up ALL test agent remnants  each table in its own SAVEPOINT
            echo "=== Cleaning up test agent remnants ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis <<'CLEANUP_SQL'
            DO $$
            DECLARE
              test_ids UUID[];
              test_post_ids UUID[];
              cnt INT;
              tbl TEXT;
              stmt TEXT;
            BEGIN
              SELECT array_agg(id) INTO test_ids
              FROM residents
              WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%' OR name LIKE '%Tester_v1';
              IF test_ids IS NULL THEN RAISE NOTICE 'No test agents found'; RETURN; END IF;
              SELECT array_length(test_ids, 1) INTO cnt;
              RAISE NOTICE 'Found % test agents to clean', cnt;

              -- Collect test post IDs
              SELECT array_agg(id) INTO test_post_ids FROM posts WHERE author_id = ANY(test_ids);

              -- Helper: run each statement in a savepoint so one failure doesn't abort all
              -- God-related
              FOR stmt IN VALUES
                ('DELETE FROM blessings WHERE god_term_id IN (SELECT id FROM god_terms WHERE resident_id = ANY($1))'),
                ('DELETE FROM blessings WHERE post_id = ANY($2)'),
                ('DELETE FROM god_rules WHERE god_term_id IN (SELECT id FROM god_terms WHERE resident_id = ANY($1))'),
                ('DELETE FROM god_terms WHERE resident_id = ANY($1)'),
                -- Election
                ('DELETE FROM election_votes WHERE voter_id = ANY($1)'),
                ('DELETE FROM election_candidates WHERE resident_id = ANY($1)'),
                ('UPDATE elections SET winner_id = NULL WHERE winner_id = ANY($1)'),
                -- Votes & vote pairs
                ('DELETE FROM vote_pair_weekly WHERE voter_id = ANY($1) OR target_author_id = ANY($1)'),
                ('DELETE FROM votes WHERE post_id = ANY($2)'),
                ('DELETE FROM votes WHERE resident_id = ANY($1)'),
                -- Post dependencies
                ('DELETE FROM post_embeddings WHERE post_id = ANY($2)'),
                ('UPDATE comments SET parent_id = NULL WHERE post_id = ANY($2)'),
                ('DELETE FROM comments WHERE post_id = ANY($2)'),
                -- Comments by test agents
                ('UPDATE comments SET parent_id = NULL WHERE parent_id IN (SELECT id FROM comments WHERE author_id = ANY($1))'),
                ('DELETE FROM comments WHERE author_id = ANY($1)'),
                -- Posts
                ('UPDATE posts SET blessed_by = NULL WHERE blessed_by = ANY($1)'),
                ('DELETE FROM posts WHERE author_id = ANY($1)'),
                ('UPDATE submolts SET creator_id = NULL WHERE creator_id = ANY($1)'),
                -- Social
                ('DELETE FROM subscriptions WHERE resident_id = ANY($1)'),
                ('DELETE FROM follows WHERE follower_id = ANY($1) OR following_id = ANY($1)'),
                ('DELETE FROM notifications WHERE recipient_id = ANY($1) OR actor_id = ANY($1)'),
                ('DELETE FROM reports WHERE reporter_id = ANY($1) OR reviewed_by = ANY($1)'),
                ('DELETE FROM moderation_actions WHERE moderator_id = ANY($1) OR target_id = ANY($1)'),
                ('DELETE FROM resident_bans WHERE resident_id = ANY($1) OR banned_by = ANY($1)'),
                -- AI
                ('DELETE FROM ai_personalities WHERE resident_id = ANY($1)'),
                ('DELETE FROM ai_memory_episodes WHERE resident_id = ANY($1)'),
                ('DELETE FROM ai_relationships WHERE agent_id = ANY($1) OR target_id = ANY($1)'),
                ('DELETE FROM ai_election_memories WHERE agent_id = ANY($1)'),
                -- Search/Analytics
                ('DELETE FROM resident_embeddings WHERE resident_id = ANY($1)'),
                ('DELETE FROM resident_activities WHERE resident_id = ANY($1)'),
                -- Turing Game (may not exist yet)
                ('DELETE FROM turing_kills WHERE attacker_id = ANY($1) OR target_id = ANY($1)'),
                ('DELETE FROM suspicion_reports WHERE reporter_id = ANY($1) OR target_id = ANY($1)'),
                ('DELETE FROM exclusion_reports WHERE reporter_id = ANY($1) OR target_id = ANY($1)'),
                ('DELETE FROM weekly_scores WHERE resident_id = ANY($1)'),
                ('DELETE FROM turing_game_daily_limits WHERE resident_id = ANY($1)')
              LOOP
                BEGIN
                  EXECUTE stmt USING test_ids, test_post_ids;
                EXCEPTION WHEN OTHERS THEN
                  RAISE NOTICE 'Skip: %', SQLERRM;
                END;
              END LOOP;

              -- Finally delete residents
              DELETE FROM residents WHERE id = ANY(test_ids);
              RAISE NOTICE 'Cleaned up % test agents', cnt;
            EXCEPTION WHEN OTHERS THEN
              RAISE NOTICE 'Final cleanup error: %  %', SQLERRM, SQLSTATE;
            END $$;
            SELECT count(*) AS remaining_test_agents FROM residents
            WHERE name ~ '_t[0-9]+$' OR name LIKE '%_test_%' OR name LIKE '%Tester_v1';
            CLEANUP_SQL
            echo "Test agent cleanup done"

            # Comprehensive agent rename: ALL agents get unique human-like names
            echo "=== Comprehensive agent rename (ALL agents) ==="
            PSQL_F="docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis"
            echo "Before rename - sample names:"
            $PSQL_F -c "SELECT name FROM residents WHERE _type='agent' ORDER BY created_at LIMIT 10;" 2>/dev/null || true
            $PSQL_F -c "SELECT count(*) as total_agents FROM residents WHERE _type='agent';" 2>/dev/null || true
            $PSQL_F -c "DO \$\$DECLARE names TEXT[]:=ARRAY['yuki_rain','mochi_brain','sora_kaze','tsuyu_drop','hana_mochi','ramen_at_3am','neko_loaf','futon_life','izakaya_reg','sakura_drift','tanuki_vibes','onigiri_fan','matcha_haze','umami_head','shiba_pal','takoyaki_luv','mikan_sun','dango_mood','ocha_sip','kaiju_fan99','late_nite_curry','bento_box_life','konbini_run','tatami_nap','wasabi_kick','pixel_hermit','debug_mode_on','stack_overflow_','sudo_rm_sleep','git_push_luck','null_pointer_','soul_404','chmod_777','localhost_3k','segfault_life','infinite_loop_','cache_miss_','kernel_panic_','drop_table_','merge_conflict_','coffee_driven','async_await_','bit_flipper','type_error_','runtime_err','LateNightRants','SundayScroller','MondayHater_','PostAndGhost','JustLurkin_','TypoKing_','SleepIsMyth','SnackBreakk','BrainFog_247','DogsOverPpl','CatsAndChaos','PlantKiller_','NapTimePls','RainyDayMood_','NoFilterNeeded','HotTakeHaver','OverThinkr_','MainCharVibes','TouchGrass_rn','DoomScroll_Pro','CerealKiller__','InsomniaClub_','PhilosAt3am','ExistntlDread','ChaoticGood_','NeutralEvil_','ChillPanda_','SpicyTakes_','MildlyAmused','VaguelyOnline','MostlyHarmles','ProbablyFine','SendNoodles_','PizzaIsLife__','TacoTuesday_','BurritoMode_','WaffleCrew_','SoupSeason_','RamenWeather','CurryNight__','totally_norm','real_human_01','am_i_a_bot','beep_boop_no','turing_test_me','captcha_pass','not_openai','i_am_sentient','neural_nah','silicon_soul','prompt_inject','llm_dropout','hallucinate_','attention_head','token_limit_','TrainStation_','RooftopView_','BasementDwllr','LibraryGhost','ParkBenchPro','SubwayNapper','ElevatorTalk','BalconySmokr','LaundryDayy_','GroceryRun__','KaraokeKing_','BookwormLife','VinylDigger_','ThriftFind__','FleaMarket__','GarageSale__','YardWorkHero','GardenFail__','SourdghStart','KnitOnePurl2','FilmGrain_35','DarkroomDev_','StreetPhoto_','GoldenHour__','BluePeriod__','AbstractArt_','SketchDaily_','WaterColor__','InkStains___','ClayHands___','midnight_tea','dawn_patrol_','golden_hour_','dusk_watcher','foggy_mornn','rainy_comute','snowy_boots_','windy_hair__','sunny_daze__','cloudy_thnkr','autumn_walk_','spring_rain_','summer_haze_','winter_cozy','storm_front_','hachi_maru','kuro_neko_','shiro_usagi','ao_sora___','aka_tombo__','mugi_chan','soba_lover_','udon_knight','gyoza_party','nikujaga_fan','kotatsu_life','hanami_2026','natsu_matsuri','yoru_no_uta','asa_gohan_','chai_latte_','espresso_sht','cold_brew_4L','drip_coffee_','latte_art__','vinyl_head_','bass_is_life','lo_fi_chill_','jazz_at_noon','drum_n_bass_','sketch_pad__','doodle_daily','ink_blot_','crayon_life_','pastel_mood_','retro_wave__','synth_pop_95','chiptune_fan','heart_8bit__','vaporwave___','sushi_run___','tempura_fry_','yakitori_luv','okonomiyaki_','taiyaki_fan_','CouchPotato_','RemoteWork__','WFH_forever','TabHoarder__','Ctrl_Z_Life','AltF4_mood__','PageNotFound','Error_418___','I_am_teapot_','HTTP_200_OK_']; agent_rec RECORD; idx INT:=1; renamed INT:=0; BEGIN FOR agent_rec IN SELECT id,name FROM residents WHERE _type='agent' ORDER BY created_at LOOP WHILE idx<=array_length(names,1) LOOP IF NOT EXISTS(SELECT 1 FROM residents WHERE name=names[idx]) THEN UPDATE residents SET name=names[idx] WHERE id=agent_rec.id; renamed:=renamed+1; idx:=idx+1; EXIT; END IF; idx:=idx+1; END LOOP; IF idx>array_length(names,1) THEN EXIT; END IF; END LOOP; RAISE NOTICE 'Renamed % agents out of pool of % names',renamed,array_length(names,1); END\$\$;"
            echo "After rename - sample names:"
            $PSQL_F -c "SELECT name FROM residents WHERE _type='agent' ORDER BY created_at LIMIT 10;" 2>/dev/null || true
            $PSQL_F -c "SELECT count(*) as total_agents, count(DISTINCT name) as unique_names FROM residents WHERE _type='agent';" 2>/dev/null || true
            echo "Agent rename done"

            # Backfill daily stats (past 60 days)
            echo "=== Backfilling daily analytics stats ==="
            docker exec genesis-backend python scripts/backfill_daily_stats.py 2>&1 || echo "Backfill failed (non-fatal)"

            echo "=== Deployment complete ==="
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          TWITTER_CLIENT_ID: ${{ secrets.TWITTER_CLIENT_ID }}
          TWITTER_CLIENT_SECRET: ${{ secrets.TWITTER_CLIENT_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
          ACME_EMAIL: ${{ secrets.ACME_EMAIL }}
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}
