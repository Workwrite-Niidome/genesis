name: Deploy GENESIS v4

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  # ============ Deploy to VPS ============
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest

    steps:
      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          command_timeout: 30m
          envs: GITHUB_TOKEN,POSTGRES_PASSWORD,REDIS_PASSWORD,SECRET_KEY,TWITTER_CLIENT_ID,TWITTER_CLIENT_SECRET,CLAUDE_API_KEY,ACME_EMAIL,TRAEFIK_USERS
          script: |
            set -e  # Exit on any error

            # Clone repo if doesn't exist or isn't a git repo
            if [ ! -d ~/genesis/.git ]; then
              echo "Setting up repository..."
              rm -rf ~/genesis
              git clone https://x-access-token:${GITHUB_TOKEN}@github.com/Workwrite-Niidome/genesis.git ~/genesis
            fi

            cd ~/genesis

            # Pull latest code (use token for auth)
            echo "Pulling latest code..."
            git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/Workwrite-Niidome/genesis.git
            git fetch origin master
            git reset --hard origin/master

            # Verify required secrets are set BEFORE doing anything
            if [ -z "${POSTGRES_PASSWORD}" ] || [ -z "${REDIS_PASSWORD}" ] || [ -z "${SECRET_KEY}" ]; then
              echo "ERROR: Required secrets (POSTGRES_PASSWORD, REDIS_PASSWORD, SECRET_KEY) are not set in GitHub Secrets"
              exit 1
            fi

            # Create/update .env file from secrets (no leading whitespace!)
            echo "Setting up environment variables..."
            echo "# Auto-generated by GitHub Actions deployment" > .env
            echo "POSTGRES_USER=genesis" >> .env
            echo "POSTGRES_DB=genesis" >> .env
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}" >> .env
            echo "REDIS_PASSWORD=${REDIS_PASSWORD}" >> .env
            echo "SECRET_KEY=${SECRET_KEY}" >> .env
            echo "TWITTER_CLIENT_ID=${TWITTER_CLIENT_ID}" >> .env
            echo "TWITTER_CLIENT_SECRET=${TWITTER_CLIENT_SECRET}" >> .env
            echo "CLAUDE_API_KEY=${CLAUDE_API_KEY}" >> .env
            echo "ACME_EMAIL=${ACME_EMAIL}" >> .env
            echo "TRAEFIK_USERS=${TRAEFIK_USERS}" >> .env

            # Show .env file (with secrets masked)
            echo "Created .env with variables:"
            cat .env | sed 's/=.*/=***/'

            # Build backend
            echo "Building backend..."
            docker build -t genesis-backend:latest ./backend

            # Build frontend
            echo "Building frontend..."
            docker build --build-arg NEXT_PUBLIC_API_URL=https://api.genesis-pj.net -t genesis-frontend:latest ./frontend

            # Stop existing containers gracefully
            echo "Stopping existing containers..."
            docker compose -f docker-compose.prod.yml down --remove-orphans || true

            # Stage 1: Start database services first (without health check wait)
            echo "Starting database services..."
            docker compose -f docker-compose.prod.yml up -d --no-deps postgres redis traefik

            # Wait for postgres to be ready (with recovery logic)
            echo "Waiting for PostgreSQL to be healthy..."
            POSTGRES_READY=false
            for i in {1..30}; do
              sleep 3
              echo "Checking PostgreSQL status... ($i/30)"

              # Check if postgres is running
              POSTGRES_STATUS=$(docker inspect --format='{{.State.Status}}' genesis-postgres 2>/dev/null || echo "not found")
              echo "PostgreSQL container status: $POSTGRES_STATUS"

              if [ "$POSTGRES_STATUS" = "running" ]; then
                # Check if it's actually accepting connections
                if docker exec genesis-postgres pg_isready -U genesis 2>/dev/null; then
                  echo "PostgreSQL is ready!"
                  POSTGRES_READY=true
                  break
                fi
              elif [ "$POSTGRES_STATUS" = "exited" ] || [ "$POSTGRES_STATUS" = "not found" ]; then
                echo "PostgreSQL failed to start. Checking logs..."
                docker logs genesis-postgres 2>&1 | tail -20 || true

                # Try resetting the volume after 3 failed attempts
                if [ $i -eq 3 ]; then
                  echo "Resetting PostgreSQL data volume..."
                  docker compose -f docker-compose.prod.yml down -v
                  docker volume rm genesis_postgres_data 2>/dev/null || true
                  docker compose -f docker-compose.prod.yml up -d --no-deps postgres redis traefik
                fi
              fi
            done

            if [ "$POSTGRES_READY" = false ]; then
              echo "ERROR: PostgreSQL failed to become ready. Final logs:"
              docker logs genesis-postgres 2>&1 | tail -50 || true
              docker compose -f docker-compose.prod.yml ps
              exit 1
            fi

            # Stage 2: Start application services
            echo "Starting application services..."
            docker compose -f docker-compose.prod.yml up -d

            # Wait for all services
            echo "Waiting for all services to be healthy..."
            sleep 10

            # Check final container status
            echo "Container status:"
            docker compose -f docker-compose.prod.yml ps

            # Check if backend is actually running
            echo "Checking backend logs..."
            docker logs genesis-backend 2>&1 | tail -20 || true

            # Run migrations with timeout
            echo "Running migrations..."
            timeout 120 docker compose -f docker-compose.prod.yml exec -T backend alembic upgrade head || {
              echo "Migration failed or timed out. Backend logs:"
              docker logs genesis-backend 2>&1 | tail -50 || true
              echo "Continuing anyway - migrations may need to be run manually"
            }

            # Final health check
            echo "Checking if services are responding..."
            sleep 5
            curl -s http://localhost:8000/api/v1/health || echo "Backend health check failed"

            echo "Deployment complete!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          TWITTER_CLIENT_ID: ${{ secrets.TWITTER_CLIENT_ID }}
          TWITTER_CLIENT_SECRET: ${{ secrets.TWITTER_CLIENT_SECRET }}
          CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
          ACME_EMAIL: ${{ secrets.ACME_EMAIL }}
          TRAEFIK_USERS: ${{ secrets.TRAEFIK_USERS }}

  # ============ Notify ============
  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()

    steps:
      - name: Check deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ GENESIS v4 deployed successfully to genesis-pj.net"
          else
            echo "❌ Deployment failed"
            exit 1
          fi
