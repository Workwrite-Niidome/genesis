name: Deploy GENESIS v4

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      mode:
        description: 'Deploy mode'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - diagnose

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/workwrite-niidome/genesis

jobs:
  # ============ Diagnose VPS (on workflow_dispatch with diagnose mode) ============
  diagnose:
    name: Diagnose VPS
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.mode == 'diagnose' }}

    steps:
      - name: Diagnose VPS Docker
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          command_timeout: 10m
          script: |
            echo "=== System Info ==="
            uname -a
            free -h
            df -h /

            echo "=== Running Containers ==="
            docker ps -a 2>&1

            echo "=== Backend Logs (last 50 lines) ==="
            docker logs genesis-backend --tail 50 2>&1 || echo "No backend logs"

            echo "=== Frontend Logs (last 20 lines) ==="
            docker logs genesis-frontend --tail 20 2>&1 || echo "No frontend logs"

            echo "=== Database Tables ==="
            cd ~/genesis 2>/dev/null
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "\dt" 2>&1 || echo "DB query failed"

            echo "=== Alembic Version ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "SELECT * FROM alembic_version;" 2>&1 || echo "No alembic_version table"

            echo "=== Firewall Status ==="
            sudo firewall-cmd --list-all 2>&1 || echo "No firewalld"
            sudo iptables -L -n --line-numbers 2>/dev/null | head -30 || echo "No iptables"

            echo "=== Test Backend Health (via python) ==="
            docker exec genesis-backend python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:8000/health').read().decode())" 2>&1 || echo "Backend health check failed"

            echo "=== Test Backend API (via python) ==="
            docker exec genesis-backend python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:8000/api/v1/posts').read().decode())" 2>&1 || echo "Backend API check failed"

            echo "=== Test Traefik (via host) ==="
            curl -s -o /dev/null -w 'HTTP %{http_code}' http://localhost:80/ 2>&1 || echo "Traefik check failed"

            echo ""
            echo "=== Test external access ==="
            curl -sv --connect-timeout 5 http://$(hostname -I | awk '{print $1}'):80/ 2>&1 | head -10 || echo "External access check failed"

            echo "=== Listening ports ==="
            ss -tlnp | grep -E ':80|:443' 2>&1 || echo "No listening ports found"

            echo "=== Cloudflare Tunnel ==="
            systemctl status cloudflared 2>&1 | head -10 || echo "No cloudflared service"
            cat /etc/cloudflared/config.yml 2>&1 || echo "No cloudflared config"

            echo "=== Docker Volumes ==="
            docker volume ls 2>&1
            echo ""
            echo "=== Volume Details ==="
            for vol in $(docker volume ls -q); do
              echo "--- Volume: $vol ---"
              docker volume inspect "$vol" 2>&1 | grep -E '"Name"|"CreatedAt"|"Mountpoint"'
            done

            echo "=== Check old postgres volumes for v4 data ==="
            for vol in $(docker volume ls -q | grep -i postgres); do
              echo "--- Checking volume: $vol ---"
              docker run --rm -v "$vol":/data alpine sh -c "ls -la /data/ 2>/dev/null | head -20" 2>&1
              echo "Checking for v4 tables (residents, posts)..."
              docker run --rm -v "$vol":/var/lib/postgresql/data -e POSTGRES_HOST_AUTH_METHOD=trust postgres:16-alpine sh -c "
                pg_isready -U genesis 2>/dev/null || {
                  pg_ctl -D /var/lib/postgresql/data start -o '-c listen_addresses=localhost' -w -t 10 2>/dev/null
                }
                psql -U genesis -d genesis -c \"SELECT count(*) AS residents FROM residents;\" 2>/dev/null || echo 'No residents table'
                psql -U genesis -d genesis -c \"SELECT count(*) AS posts FROM posts;\" 2>/dev/null || echo 'No posts table'
                psql -U genesis -d genesis -c \"SELECT count(*) AS submolts FROM submolts;\" 2>/dev/null || echo 'No submolts table'
                psql -U genesis -d genesis -c \"SELECT id, name, _type, created_at FROM residents LIMIT 10;\" 2>/dev/null || echo 'No resident data'
                psql -U genesis -d genesis -c \"SELECT id, title, submolt, created_at FROM posts LIMIT 10;\" 2>/dev/null || echo 'No post data'
                pg_ctl -D /var/lib/postgresql/data stop -w 2>/dev/null
              " 2>&1 || echo "Could not check volume $vol"
            done

            echo "=== Diagnostics Complete ==="

  # ============ Build and Push Images ============
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.mode == 'full') }}
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ env.IMAGE_PREFIX }}/backend:latest,${{ env.IMAGE_PREFIX }}/backend:${{ github.sha }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,scope=backend,mode=max

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ env.IMAGE_PREFIX }}/frontend:latest,${{ env.IMAGE_PREFIX }}/frontend:${{ github.sha }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,scope=frontend,mode=max

  # ============ Deploy to VPS ============
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: build
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.mode == 'full') }}

    steps:
      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          command_timeout: 30m
          envs: GITHUB_TOKEN,POSTGRES_PASSWORD,REDIS_PASSWORD,SECRET_KEY,TWITTER_CLIENT_ID,TWITTER_CLIENT_SECRET,CLAUDE_API_KEY,ACME_EMAIL,IMAGE_PREFIX
          script: |
            set -e

            echo "=== System Status ==="
            df -h / | tail -1
            free -h

            # Create swap if not present (VPS has only 2GB RAM, no swap - Docker needs it)
            if [ ! -f /swapfile ]; then
              echo "=== Creating 4GB swap file ==="
              sudo fallocate -l 4G /swapfile
              sudo chmod 600 /swapfile
              sudo mkswap /swapfile
              sudo swapon /swapfile
              echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
              echo "Swap created and enabled"
            elif ! swapon --show | grep -q /swapfile; then
              echo "=== Enabling existing swap ==="
              sudo swapon /swapfile
            fi
            free -h

            # Restart Docker to clear any stuck state from OOM
            echo "=== Restarting Docker ==="
            sudo systemctl restart docker
            sleep 10

            # Ensure Docker is running
            if ! timeout 60 docker info > /dev/null 2>&1; then
              echo "ERROR: Docker still unresponsive after restart"
              exit 1
            fi
            echo "Docker is responsive"

            # Ensure firewall allows HTTP/HTTPS (RHEL/CentOS firewalld)
            echo "=== Configuring firewall ==="
            if command -v firewall-cmd &> /dev/null; then
              sudo firewall-cmd --zone=public --add-port=80/tcp --permanent 2>/dev/null || true
              sudo firewall-cmd --zone=public --add-port=443/tcp --permanent 2>/dev/null || true
              sudo firewall-cmd --zone=public --add-masquerade --permanent 2>/dev/null || true
              sudo firewall-cmd --reload 2>/dev/null || true
              echo "Firewall configured"
            else
              echo "No firewalld, skipping"
            fi

            # Update code
            cd ~/genesis || {
              rm -rf ~/genesis
              git clone https://x-access-token:${GITHUB_TOKEN}@github.com/Workwrite-Niidome/genesis.git ~/genesis
              cd ~/genesis
            }
            git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/Workwrite-Niidome/genesis.git
            git fetch --prune origin
            git checkout master 2>/dev/null || git checkout -b master origin/master
            git reset --hard origin/master

            # Create .env file
            echo "POSTGRES_USER=genesis" > .env
            echo "POSTGRES_DB=genesis" >> .env
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}" >> .env
            echo "REDIS_PASSWORD=${REDIS_PASSWORD}" >> .env
            echo "SECRET_KEY=${SECRET_KEY}" >> .env
            echo "TWITTER_CLIENT_ID=${TWITTER_CLIENT_ID}" >> .env
            echo "TWITTER_CLIENT_SECRET=${TWITTER_CLIENT_SECRET}" >> .env
            echo "CLAUDE_API_KEY=${CLAUDE_API_KEY}" >> .env
            echo "ACME_EMAIL=${ACME_EMAIL}" >> .env
            echo "TRAEFIK_USERS=" >> .env

            # Update Cloudflare Tunnel to route directly to services (bypass Traefik)
            # Cloudflare handles TLS termination, so no need for Traefik in the middle
            if [ -f /etc/cloudflared/config.yml ]; then
              echo "=== Updating Cloudflare Tunnel config ==="
              TUNNEL_ID=$(grep 'tunnel:' /etc/cloudflared/config.yml | awk '{print $2}')
              CREDS_FILE="/etc/cloudflared/${TUNNEL_ID}.json"
              echo "tunnel: ${TUNNEL_ID}" | sudo tee /etc/cloudflared/config.yml > /dev/null
              echo "credentials-file: ${CREDS_FILE}" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "ingress:" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - hostname: genesis-pj.net" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "    service: http://localhost:3000" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - hostname: www.genesis-pj.net" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "    service: http://localhost:3000" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - hostname: api.genesis-pj.net" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "    service: http://localhost:8000" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              echo "  - service: http_status:404" | sudo tee -a /etc/cloudflared/config.yml > /dev/null
              sudo systemctl restart cloudflared
              echo "Cloudflare Tunnel updated: frontend=:3000, api=:8000"
            fi

            # Login to GHCR
            echo "${GITHUB_TOKEN}" | docker login ghcr.io -u github --password-stdin

            # Pull latest images
            echo "=== Pulling backend image ==="
            docker pull ${IMAGE_PREFIX}/backend:latest
            echo "=== Pulling frontend image ==="
            docker pull ${IMAGE_PREFIX}/frontend:latest

            # Tag images for docker-compose
            docker tag ${IMAGE_PREFIX}/backend:latest genesis-backend:latest
            docker tag ${IMAGE_PREFIX}/frontend:latest genesis-frontend:latest

            # Stop ALL old containers (including genesis_v4-* from old docker-compose)
            echo "=== Cleaning up old containers ==="
            docker compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
            docker compose down --remove-orphans 2>/dev/null || true
            # Force stop any remaining genesis containers
            docker ps -a --filter "name=genesis" -q | xargs -r docker rm -f 2>/dev/null || true

            # Start services
            docker compose -f docker-compose.prod.yml up -d

            # Wait for database to be healthy
            echo "=== Waiting for database ==="
            for i in $(seq 1 30); do
              if docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U genesis 2>/dev/null; then
                echo "Database ready"
                break
              fi
              echo "Waiting... ($i/30)"
              sleep 2
            done

            # Sync PostgreSQL password with .env (volume may have been initialized with a different password)
            echo "=== Syncing database password ==="
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "ALTER USER genesis WITH PASSWORD '${POSTGRES_PASSWORD}';" 2>/dev/null || echo "Password sync skipped"

            # Fix alembic version if needed
            echo "=== Fixing migration state ==="
            # Remove stale revisions from old schema
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "DELETE FROM alembic_version WHERE version_num NOT IN ('001', '002', '003_ai_personality', '004_phase4', '005_phase5', '006_fix_submolts', '007_karma_as_life');" 2>/dev/null || true
            # If submolts.creator_id exists, 006 is done â€” stamp to 006_fix_submolts so 007 can run
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "UPDATE alembic_version SET version_num = '006_fix_submolts' WHERE version_num = '005_phase5' AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'submolts' AND column_name = 'creator_id');" 2>/dev/null || true
            # If alembic_version is empty but tables exist, stamp to 006 (all prior migrations applied)
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U genesis -c "INSERT INTO alembic_version (version_num) SELECT '006_fix_submolts' WHERE NOT EXISTS (SELECT 1 FROM alembic_version) AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'residents');" 2>/dev/null || true

            # Run migrations
            echo "=== Running migrations ==="
            docker compose -f docker-compose.prod.yml exec -T backend alembic upgrade head || echo "Migration warning (may already be up to date)"

            # Restart backend to pick up password change and fresh DB connection
            echo "=== Restarting backend ==="
            docker compose -f docker-compose.prod.yml restart backend celery-worker celery-beat
            sleep 5

            # Clean up old images
            docker image prune -f 2>/dev/null || true

            # Show final status
            echo "=== Service Status ==="
            docker compose -f docker-compose.prod.yml ps

            echo "=== Deployment complete ==="
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          TWITTER_CLIENT_ID: ${{ secrets.TWITTER_CLIENT_ID }}
          TWITTER_CLIENT_SECRET: ${{ secrets.TWITTER_CLIENT_SECRET }}
          CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
          ACME_EMAIL: ${{ secrets.ACME_EMAIL }}
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}
